{
  "-/from/Coll-Bridge/types/None": {
    "code": "def operate(state, self, operator, other):\n    return \"None\"\n\n\ndef is_super_type(sub_type):\n    return False\n\n\ndef get_super_type(self_type, other_type):\n    return other_type\n\n\ndef typecast(state, value, other_type):\n    return f\"{other_type}({value})\"\n"
  },
  "-/from/Coll-Bridge/types/bool": {
    "code": "def operate(state, self, operator, other):\n    return \"bool\"\n\n\ndef is_super_type(sub_type):\n    return False\n\n\ndef typecast(state, value, other_type):\n    return f\"{other_type}({value})\"\n"
  },
  "-/from/Coll-Bridge/types/dict": {
    "code": "def operate(state, self, operator, other):\n    if operator == \"[]\":\n        pair_value = operator.tags[\"pair_value\"]\n        keys = [state.words[k.start:k.end] for k in self.info[\"keys\"]]\n        if len(pair_value) == 1 and pair_value in keys:\n            return self.info[\"type_sets\"][1][keys.index(pair_value)]\n        return \"None\"\n    return \"dict\"\n\n\ndef is_super_type(sub_type):\n    return False\n\n\ndef get_super_type(self_type, other_type):\n    return self_type\n\n\ndef typecast(state, value, other_type):\n    return f\"{other_type}({value})\"\n"
  },
  "-/from/Coll-Bridge/types/float": {
    "code": "def operate(state, self, operator, other):\n    return \"float\"\n\n\ndef is_super_type(sub_type):\n    return sub_type == \"int\"\n\n\ndef get_super_type(self_type, other_type):\n    return \"float\"\n\n\ndef typecast(state, value, other_type):\n    return f\"{other_type}({value})\"\n"
  },
  "-/from/Coll-Bridge/types/int": {
    "code": "def operate(state, self, operator, other):\n    if operator == \"/\" and other == \"int\":\n        return \"float\"\n    if operator == \"in\" and other == \"list\":\n        return \"bool\"\n    if other is None:\n        return \"int\"\n    return other\n\n\ndef get_super_type(self_type, other_type):\n    if other_type.base_eq == \"float\":\n        return \"float\"\n    if other_type.base_eq == \"str\":\n        return \"str\"\n    return \"int\"\n\n\ndef is_super_type(sub_type):\n    return False\n\n\ndef typecast(state, value, other_type):\n    return f\"{other_type}({value})\"\n"
  },
  "-/from/Coll-Bridge/types/list": {
    "code": "def operate(state, self, operator, other):\n    if operator == \"[]\" and (other == \"int\" or other == \"double\"):\n        return self.get_super_type(self.info[\"type_set\"])\n    if operator == \"not\":\n        return \"bool\"\n    if operator == \"+\" and other == \"list\":\n        list_type = state.all_types_from[\"list\"].copy(True)\n        list_type.info[\"type_set\"] = self.info[\"type_set\"].copy()\n        list_type.info[\"type_set\"].extend(other.info[\"type_set\"])\n        if \"List\" in self.flags or \"List\" in other.flags:\n            list_type.flags.add(\"List\")\n        if \"ArrayList\" in self.flags or \"ArrayList\" in other.flags:\n            list_type.flags.add(\"ArrayList\")\n        if \"iter_comp\" in other.info or \"iter_comp\" in self.info:\n            list_type.flags.add(\"ArrayList\")\n        return list_type\n    return \"list\"\n\n\ndef is_super_type(sub_type):\n    return False\n\n\ndef get_super_type(self_type, other_type):\n    if other_type not in self_type.info[\"type_set\"]:\n        self_type.info[\"type_set\"].add(other_type)\n    return self_type\n\n\ndef typecast(state, value, other_type):\n    return f\"{other_type}({value})\"\n"
  },
  "-/from/Coll-Bridge/types/str": {
    "code": "def get_super_type(self_type, other_type):\n    return self_type\n\n\ndef is_super_type(sub_type):\n    return True\n\n\ndef operate(state, self, operator, other):\n    if operator in [\"in\", \"not\", \"not in\"]:\n        return \"bool\"\n    if operator == \"[]\":\n        str_val = self.copy(True)\n        str_val.info[\"length\"] = 1\n        return str_val\n    return \"str\"\n\n\ndef typecast(state, value, other_type):\n    return f\"{other_type}({value})\"\n"
  },
  "-/from/Coll-Bridge/types/tuple": {
    "code": "def operate(state, self, operator, other):\n    if operator == \"[]\":\n        elem_indexed = None\n        pair_value = operator.tags[\"pair_value\"]\n        if len(pair_value) == 1 and pair_value[0].isdigit():\n            elem_indexed = int(operator.tags[\"pair_value\"][0])\n        if elem_indexed is not None and self.info[\"elem_count\"] > elem_indexed:\n            return self.info[\"types\"][elem_indexed]\n    return \"tuple\"\n\n\ndef is_super_type(sub_type):\n    return False\n\n\ndef get_super_type(self_type, other_type):\n    if other_type not in self_type.info[\"type_set\"]:\n        self_type.info[\"type_set\"].add(other_type)\n    return self_type\n\n\ndef typecast(state, value, other_type):\n    return f\"{other_type}({value})\"\n"
  },
  "-/from/defaults": {
    "code": "def main(state, new_capsule, **kwargs):\n    for (name, type_from) in [(\"__name__\", \"str\")]:\n        new_capsule.variable(state, name,\n                             type_from=state.all_types_from[type_from])\n\n    in_built_funcs = [\"pow\", \"range\", \"len\", \"print\", \"str\", \"int\", \"bool\",\n                      \"max\", \"min\", \"list\"]\n    for in_built_func in in_built_funcs:\n        state.import_default_lib(in_built_func)\n"
  },
  "-/from/func_parser": {
    "code": "def get_args(abs_i, args):\n    name, name_i, val_top = [], -1, -1\n    skip_till = -1\n    for i, arg in enumerate(args):\n        if \"pair\" in arg.tags and arg.tags[\"pair\"] > i + abs_i:\n            skip_till = arg.tags[\"pair\"]\n        if i + abs_i > skip_till:\n            skip_till = -1\n        if arg == \",\" and skip_till == -1:\n            val_rng = range(abs_i+val_top, abs_i+i) if val_top != -1 else None\n            yield abs_i + name_i, name, val_rng\n            name, name_i, val_top = [], -1, -1\n        else:\n            if name_i == -1:\n                name, name_i = [arg], i\n            elif arg == \"=\":\n                val_top = i + 1\n            elif val_top == -1:\n                name.append(arg)\n    if name_i != -1:\n        val = range(abs_i+val_top, abs_i+len(args)) if val_top != -1 else None\n        yield abs_i + name_i, name, val\n\n\ndef check_is_init_call(state, call_path):\n    if \"(\" in call_path:\n        call_path = call_path[:call_path.index(\"(\")]\n    call_path_str = \"\".join(call_path)\n\n    obj_res = None\n    if call_path and call_path[0].tok_type == \"name\":\n        obj_res = state.find_in_scope(call_path_str, call_path[0].index,\n                                      throw_error=False, all_parts=True)\n\n    if not obj_res:\n        return False\n\n    if obj_res[-1].is_struct:\n        return obj_res\n    return False\n\n\ndef check_call(index, func_name_index, args, words, state, end):\n\n    start = index\n    end += 1\n\n    call_path = check_is_init_call(state, words[index:func_name_index+1])\n    is_init_call = bool(call_path)\n    if call_path is False:\n        call_path = words[index:func_name_index+1]\n\n    call_resp = {\"args\": args, \"args_range\": (func_name_index+1, end),\n                 \"start\": start, \"end\": end, \"call_path\": call_path,\n                 \"words_loc\": (index, func_name_index+1)}\n\n    if is_init_call:\n        path_name = \".\".join([p.abs_name for p in call_path if p.is_struct])\n\n        # struct_var = state.find_in_scope(words[index:func_name_index+1])\n        type_name = call_path[-1].ref_loc.get_str_struct()\n        call_resp[\"values\"] = [state.all_types_from[type_name]]\n        call_resp[\"call_path\"] = path_name + \".__init__\"\n\n    return call_resp\n\n\ndef check_def(index, args, words, state, str_funcs, end):\n    if words[index-1] != 'def' or words[end+1] != \":\":\n        return False\n\n    call_path = [words[index]]\n\n    # Arguments format [index, arg_name, arg_value],\n    # see print output of argument w/ name 'self'\n    j = str_funcs.find_prev_word(index-2)\n\n    if not(words[j] == \"staticmethod\" and words[j-1] == \"@\"):\n        struct_upper = state.get_struct_upper(index-1)\n        if struct_upper:\n            args[0][\"type_to\"] = struct_upper.type_\n            args[0][\"type_from\"] = struct_upper.type_from\n            args[0][\"attrs\"] = struct_upper.self_obj.attrs\n\n    scope = \"\"\n    if words[index].startswith(\"__\"):\n        scope = \"private\"\n\n    start = index-1\n    end += 3\n\n    pos_args, kw_args = [], []\n    for arg in args:\n        if words[arg[\"index\"]+1] == \"=\":\n            kw_args.append(arg[\"ref_loc\"][0])\n        else:\n            pos_args.append(arg[\"ref_loc\"][0])\n    \n    upper = state.get_upper(index)\n    if hasattr(upper, \"is_struct\") and upper.is_struct:\n        scope = \"\"\n        pos_args.pop(0)\n    \n    modifier = \"\"\n    def_resp = {\"args\": args, \"pos_args\": pos_args, \"kw_args\": kw_args,\n                \"start\": start, \"args_range\": (index+1, end), \"end\": end,\n                \"scope\": scope, \"call_path\": call_path, \"modifier\": modifier,\n                \"words_loc\": (index, index+1)}\n\n    if call_path == [\"__init__\"]:\n        type_name = state.get_struct_upper(index-1).ref_loc.get_str_struct()\n        def_resp[\"values\"] = [state.all_types_from[type_name]]\n    return def_resp\n\n\ndef parse(index, str_funcs, state, words, checks=None, **kwargs):\n\n    if checks is None:\n        checks = 3\n\n    func_name = str_funcs.get_identifier_name(index)\n\n    if words[func_name+1] != \"(\":\n        return\n\n    if words[index-1] == \".\":\n        if words[index-2] in str_funcs.matchable:\n            index = words[index-2].tags[\"pair\"]\n        elif \"const\" in words[index-2].tags:\n            index -= 2\n    args_str, end = str_funcs.pair_char(words, func_name+1)\n\n    args = []\n    for arg_index, name, val_rng in get_args(func_name+2, args_str):\n        arg = {\"index\": arg_index, \"ref_loc\": name, \"val_rng\": val_rng,\n               \"type_to\": None, \"type_from\": None}\n        args.append(arg)\n\n    if checks & 1:\n        def_res = check_def(index, args, words, state, str_funcs, end)\n        if def_res:\n            def_res[\"usage\"] = \"def\"\n            return def_res\n\n    if checks & 2:\n        call_res = check_call(index, func_name, args, words, state, end)\n        if call_res:\n            call_res[\"usage\"] = \"call\"\n            return call_res\n\n\ndef check_body(**kwargs):\n    kwargs[\"checks\"] = 1\n    return parse(**kwargs)\n\n\ndef check_no_body(**kwargs):\n    kwargs[\"checks\"] = 2\n    return parse(**kwargs)\n"
  },
  "-/from/get_type": {
    "code": "def solve_types(value, str_funcs, state, words, **kwargs):\n\n    # If value is empty, return None type\n    all_types = state.all_types_from\n    if not value or value == [None]:\n        return all_types[\"None\"]\n\n    str_funcs.solve_type(value)\n\n    if len(value) == 1:\n        value = value[0]\n        if value.__class__.__name__ != \"Type\":\n            raise TypeError(\"Unable to Detect Type of '{}'\".format(value))\n    else:\n        raise TypeError(\"Unable to Detect Type of '{}'\".format(value))\n\n    return value\n\n\ndef run_func_ops(op, i, val, all_types):\n    if op == \".\":\n        handle_dot_op(i, val, all_types)\n\n\ndef handle_dot_op(i, val, all_types):\n    len_val = len(val)\n    j = i\n    while len_val > j + 2 and val[j+2] == \".\":\n        j += 2\n\n    lhs = val[i].tags[\"lhs\"][0]\n    if \"var_usage\" in lhs.tags:\n        obj = lhs.tags[\"var_usage\"].obj\n        type_ = obj.type_from\n    elif \"obj_usage\" in lhs.tags:\n        obj = lhs.tags[\"obj_usage\"].obj\n        type_ = obj.type_from\n    elif \"func_usage\" in lhs.tags:\n        obj = lhs.tags[\"func_usage\"].func\n        type_ = obj.get_type_from()\n    elif \"const\" in lhs.tags:\n        type_ = all_types[lhs.tags[\"const\"]]\n    else:\n        raise ValueError(\"Unable to detect type of LHS\")\n    # val[i-1:j+2] = [type_]\n    val.solve_operator(i-1, j+2, type_)\n\n\ndef preprocess_val(state, value, **kwargs):\n    all_types = state.all_types_from\n    value = detect_iter_comp(state, value, all_types)\n    value = detect_lists(state, value, all_types)\n    value = detect_dicts(state, value, all_types)\n    return value\n\n\ndef detect_iter_comp(state, value, all_types):\n    if len(value) < 4:\n        return value\n    for i in range(value.start, value.end):\n        word = state.words[i]\n        if \"iter_comp\" in word.tags:\n            if word.tags[\"iter_comp\"] == \"list\":\n                comp_res_rng = word.tags[\"comp_res_rng\"]\n                value_list = state.words[comp_res_rng.start:comp_res_rng.stop]\n                value_obj = state.new_capsule.variable_value(\n                    value_list, state, comp_res_rng.start, comp_res_rng.stop)\n                for j in range(i, value.end):\n                    word_in = state.words[j]\n                    if word_in == \"in\":\n                        state.solve_type(word_in.tags[\"rhs\"])\n                type_set_from = state.solve_type(value_obj)\n                type_ = all_types[\"list\"].copy(True)\n                type_.info[\"type_set\"] = [type_set_from]\n                type_.info[\"iter_comp\"] = \"list\"\n\n                if comp_res_rng.start - 1 <= value.start:\n                    value.set_type(0, len(value), type_)\n                else:\n                    i_diff = value.start\n                    set_start = comp_res_rng.start - i_diff - 1\n                    set_end = value[set_start].tags[\"pair\"].index - i_diff + 1\n                    value.set_type(set_start, set_end, type_)\n    return value\n\n\ndef detect_lists(state, value, all_types):\n    def solve_list(list_val):\n        type_set = []\n        if len(list_val) > 1 and list_val[0] == \"[\" and list_val[-1] == \"]\":\n            for elem in state.str_funcs.get_element(\n                    list_val, 1, len(list_val) - 1, list_val[0].index):\n                type_from = state.solve_type(elem)\n                type_set.append(type_from)\n            type_ = all_types[\"list\"].copy(True)\n            type_.info[\"type_set\"] = type_set\n            return [type_]\n        return [all_types[\"list\"]]\n\n    brackets_stack = []\n    ignore_brackets = []\n    for i, word in enumerate(value):\n        if word == \"[\":\n            brackets_stack.append(i)\n            if i != 0 and not isinstance(value[i - 1], str):\n                ignore_brackets.append(i)\n        elif word == \"]\":\n            if len(brackets_stack) == 1:\n                start = brackets_stack.pop()\n                if start in ignore_brackets:\n                    continue\n                solved_list = solve_list(value[start:i+1])\n                if solved_list:\n                    # value[start:i+1] = solved_list\n                    value.solve_operator(start, i+1, solved_list[0])\n            else:\n                brackets_stack.pop()\n    return value\n\n\ndef detect_dicts(state, value, all_types):\n    def solve_dict(dict_val):\n        type_sets = [[], []]\n        if len(dict_val) > 1 and dict_val[0] == \"{\" and dict_val[-1] == \"}\":\n            keys = []\n            values = []\n            for pair_val in state.str_funcs.get_element(\n                    dict_val, 1, len(dict_val) - 1, dict_val[0].index):\n\n                colon_index = pair_val.index(\":\")\n                dict_colon = pair_val[colon_index]\n                key_list = pair_val[:colon_index]\n                key_val = state.new_capsule.variable_value(\n                    key_list, state, pair_val.start, dict_colon.index)\n                var_val_rng = (dict_colon.index + 1, pair_val.end)\n                value_val = state.new_capsule.variable_value(\n                    state.words[var_val_rng[0]: var_val_rng[1]],\n                    state, *var_val_rng)\n                keys.append(key_val)\n                values.append(value_val)\n                for j, elem in enumerate([key_val, value_val]):\n                    type_sets[j].append(state.solve_type(elem))\n            type_ = all_types[\"dict\"].copy(True)\n            type_.info[\"type_sets\"] = type_sets\n            type_.info[\"types\"] = [sum(type_set,\n                                       start=next(iter(type_set)))\n                                   for type_set in type_sets]\n            type_.info[\"keys\"] = keys\n            type_.info[\"values\"] = values\n            if (value.start, value.end) not in state.range_flags:\n                state.range_flags[(value.start, value.end)] = set()\n            state.range_flags[(value.start, value.end)].add(\"is_const\")\n            return [type_]\n\n    brackets_stack = []\n    for i, word in enumerate(value):\n        if word == \"{\":\n            brackets_stack.append(i)\n        elif word == \"}\":\n            if len(brackets_stack) == 1:\n                start = brackets_stack.pop()\n                solved_dict = solve_dict(value[start:i+1])\n                if solved_dict:\n                    # value[start:i+1] = solved_list\n                    value.solve_operator(start, i+1, solved_dict[0])\n            else:\n                brackets_stack.pop()\n    return value\n\n\ndef custom_ops(state, val, i, all_types):\n    op = val[i]\n    if op == \"[\":\n\n        rhs, rhs_end = state.str_funcs.pair_char(val, i)\n\n        lhs_rng = (i-1, i)\n        rhs_rng = (i+1, rhs_end+1)\n\n        if str(val[i-1]) == \"list\" and \"type_set\" in val[i-1].info:\n            type_set_iter = iter(val[i-1].info[\"type_set\"])\n            res_type = sum(type_set_iter, start=next(type_set_iter))\n        else:\n            bracket_word = state.new_capsule.word(\"[]\", type_=val[i].tok_type)\n            bracket_word.tags = val[i].tags\n            bracket_word.index = val[i].index\n            res_type = val[i-1].get_opr_res(bracket_word, val[i+1])\n            if isinstance(res_type, str):\n                res_type = all_types[res_type]\n        # val[lhs_rng[0]:rhs_rng[1]] = [res_type]\n        val.solve_operator(lhs_rng[0], rhs_rng[1], res_type)\n\n    elif op == \"not\":\n\n        if val[i+1] == \"in\":\n            val.solve_operator(i-1, i+3, all_types[\"bool\"])\n\n\ndef in_assignment(state):\n    return state.all_types_to[\"bool\"]\n\n\ndef for_in_assignment(var, type_, all_types):\n\n    if type_ == \"list\":\n        if len(type_.info[\"type_set\"]) == 0:\n            return all_types[\"None\"]\n        type_set_iter = iter(type_.info[\"type_set\"])\n        return sum(type_set_iter, start=next(type_set_iter))\n    if type_ == \"range\":\n        return all_types[\"int\"]\n    if type_ == \"str\":\n        str_type = all_types[\"str\"].copy(True)\n        str_type.info[\"length\"] = 1\n        return str_type\n    if type_ == \"dict_items\":\n        prev_var = var.value[0].tags[\"func_usage\"].call_path[-2]\n        tuple_type = all_types[\"tuple\"].copy(True)\n        tuple_type.info[\"types\"] = prev_var.type_from.info[\"types\"]\n        tuple_type.info[\"elem_count\"] = len(prev_var.type_from.info[\"types\"])\n        tuple_type.info[\"cause\"] = \"dict_items\"\n        return tuple_type\n    if type_ == \"dict\":\n        return type_.info[\"types\"][0]\n\n\ndef assignment_stmt_mod(state, type_, words, var, all_types):\n    assignment_type = var.assignment_type\n    value = var.value\n    if assignment_type == \"in\":\n        var_usage = next(iter(var.usages[\"set\"].values()))\n        if words[var_usage.obj_stmt.start-1] == \"for\":\n            return for_in_assignment(var, type_, all_types)\n    return type_\n"
  },
  "-/from/get_val": {
    "code": "def dfs_names(end, words, str_funcs, name, rec_i):\n    name_word = words[name[0]:name[1]]\n    if name_word[0] in str_funcs.matchable:\n        queue_names = str_funcs.get_collection_queue(words, name[0]+1, end-1)\n        for j, name_l in enumerate(queue_names):\n            for res in dfs_names(end, words, str_funcs, name_l, rec_i + [j]):\n                yield res\n    else:\n        yield name_word, rec_i, name[0]\n\n\ndef dfs_values(val_index, str_funcs, val_list, words):\n    k = 0\n    while val_index:\n        if len(val_index) > 1:\n            i = val_index.pop(0)\n            start, end = val_list[i][0], val_list[i][1]\n            val_list = str_funcs.get_collection_queue(words, start+1, end-1)\n            if len(val_list) == 1 and val_list[0][1] <= val_list[0][0]:\n                return -1, k, words[start:end], start\n        else:\n            value = words[val_list[val_index[0]][0]: val_list[val_index[0]][1]]\n            return value, val_list[val_index[0]][0]\n        k += 1\n\n\ndef get_var_usage_wrapper(state, new_capsule, new_var, stmt, equals, words):\n    def get_var_usage(name, index, value, val_index):\n        i, j = 0, 0\n        c_path = name.copy()\n        len_c_path = len(c_path)\n        while i < len(name):\n            if name[i] == \"[\":\n                size = name[i].tags[\"pair\"] - name[i].index\n                elem_name = \"{}[\".format(name[i - 1])\n                elem_word = new_capsule.word(elem_name, type_=\"name\")\n                name[i:i + size + 1] = [\".\", elem_word]\n                obj_coll_name = \"\".join(c_path[j + 1:j + size])\n                word = new_capsule.object(\n                    state, abs_name=obj_coll_name, ref_loc=obj_coll_name,\n                    is_word_coll=True, word_coll=c_path[j + 1:j + size],\n                    use_ref_loc=True, is_const=True)\n                c_path[j + 1:j + size] = [word]\n\n                i += 1\n                j += 2\n            i += 1\n            j += 1\n\n        var = new_var(name, index=index, assignment_type=words[equals])\n        var.setup(value, val_index)\n\n        return new_capsule.variable_usage(\n            state, index, stmt[\"start\"], stmt[\"end\"],\n            (index, index + len_c_path), c_path, var, \"set\")\n    return get_var_usage\n\n\ndef handle_over_index(state, oi_nvs, over_index):\n    _, oi_point, oi_value, oi_index = over_index\n\n    oi_end = oi_index + len(oi_value)\n    over_index_list = []\n    for oi_nv in oi_nvs:\n        for j in oi_nv[1][oi_point:]:\n            over_index_list += oi_value + [\"[\", str(j), \"]\", \",\"]\n    state.add_correction(oi_index, oi_end,\n                         [\"(\"] + over_index_list[:-1] + [\")\"])\n\n\ndef handle_over_index_in(iter_name, oi_nvs, over_index):\n    _, oi_point, oi_value, oi_index = over_index\n\n    over_index_list = []\n    for oi_nv in oi_nvs:\n        for j in oi_nv[1][oi_point:]:\n            over_index_list += [iter_name, \"[\", str(j), \"]\", \",\"]\n    return [\"(\"] + over_index_list[:-1] + [\")\"]\n\n\ndef main(stmt, words, str_funcs, new_capsule, state, new_var, **kwargs):\n\n    nvs = []\n    oi_nvs = []\n    oi_dat = None\n    chain_cut = False\n    equals = stmt[\"equals\"]\n    names = str_funcs.get_collection_queue(words, stmt[\"start\"], equals)\n    values = str_funcs.get_collection_queue(words, equals+1, stmt[\"end\"])\n    get_var_usage = get_var_usage_wrapper(state, new_capsule, new_var, stmt,\n                                          equals, words)\n\n    split_for = (words[equals] == \"in\" and names[0][1] - names[0][0] > 1)\n    if len(names) > len(values) or split_for:\n        if len(values) == 1:\n            oi_nvs = []\n            value = words[values[0][0]:values[0][1]]\n            val_index = values[0][0]\n            if words[equals] == \"in\":\n                if len(names) == 1 and words[stmt[\"start\"]] == \"(\":\n                    names = str_funcs.get_collection_queue(\n                        words, stmt[\"start\"]+1, equals-1)\n                    names[0] = (names[0][0], names[0][1])\n            for i, name_c in enumerate(names):\n                oi_nvs.append((words[name_c[0]: name_c[1]], [i], name_c[0]))\n                nvs.append(get_var_usage(words[name_c[0]: name_c[1]],\n                                         name_c[0], value, val_index))\n            oi_dat = (-1, 0, value, val_index)\n\n            if words[equals] == \"=\":\n                handle_over_index(state, oi_nvs, oi_dat)\n                state.add_correction(\n                    stmt[\"start\"], equals,\n                    [\"(\"] + words[stmt[\"start\"]: equals] + [\")\"])\n            elif words[equals] == \"in\":\n                item_var_name = state.get_new_obj_name(\n                    stmt[\"start\"], prefix=\"item\")\n                state.add_correction(\n                    stmt[\"start\"], equals, [item_var_name])\n\n                tuple_val = handle_over_index_in(item_var_name, oi_nvs, oi_dat)\n                var_name = words[stmt[\"start\"]:stmt[\"equals\"]]\n                if words[stmt[\"start\"]] != \"(\":\n                    var_name = [\"(\"] + var_name + [\")\"]\n                correction = (\n                    var_name + [\"=\"] + tuple_val + [\"\\n\", words[stmt[\"end\"]+3]]\n                )\n                state.add_correction(stmt[\"end\"]+3, stmt[\"end\"]+4, correction)\n            return nvs\n        raise ValueError(\"Invalid variable set statement\")\n    for i, name_c in enumerate(names):\n        for name, vi, index in dfs_names(\n                equals, words, str_funcs, name_c, [i]):\n            values_resp = dfs_values(vi, str_funcs, values, words)\n            if values_resp[0] == -1:\n                if oi_dat is None:\n                    oi_dat = values_resp\n                chain_cut = oi_dat != values_resp\n                if not chain_cut:\n                    oi_nvs.append((name, vi, index))\n                    values_resp = values_resp[2:]\n            elif oi_dat is not None:\n                chain_cut = True\n\n            if chain_cut:\n                handle_over_index(state, oi_nvs, oi_dat)\n                chain_cut = False\n                if values_resp[0] == -1:\n                    oi_dat = values_resp\n                    oi_nvs = [(name, vi, index)]\n                    values_resp = values_resp[2:]\n                else:\n                    oi_dat = None\n                    oi_nvs.clear()\n\n            value, val_index = values_resp\n            nvs.append(get_var_usage(name, index, value, val_index))\n        if oi_dat is not None:\n            handle_over_index(state, oi_nvs, oi_dat)\n            chain_cut = False\n            oi_dat = None\n            oi_nvs.clear()\n    return nvs\n"
  },
  "-/from/lib_parser": {
    "code": "def parse(index, str_funcs, words, **kwargs):\n    start = str_funcs.find_start(index) + 1\n    end = words[index].tags[\"kw_follower_value\"].end\n    lib_stmt = words[start:end]\n\n    lib_name, as_start = \"\", end\n    if \"as\" in lib_stmt:\n        as_start = lib_stmt.index(\"as\")\n        abs_start = as_start + start\n        lib_name = words[abs_start+1:str_funcs.find_end(abs_start)][0]\n\n    lib_path, from_end = \"\", 0\n    if lib_stmt[0] == \"from\":\n        lib_path = words[start+1:index][0] + \".\"\n\n    import_name = lib_stmt[index-start+1:as_start][0]\n    lib_path += import_name\n    if not lib_name:\n        lib_name = import_name\n\n    return [(start, end, lib_path, lib_name)]\n"
  },
  "-/from/preprocessor": {
    "code": "def preprocess(re, file_lns, **kwargs):\n    skip_till = \"\"\n    escaped = False\n    skip = 0\n    bracket_stack = []\n    brackets = {\")\": \"(\", \"]\": \"[\", \"}\": \"{\"}\n    brackets_start = list(brackets.values())\n    for i, ln in enumerate(file_lns):\n        for j, char in enumerate(ln):\n            if escaped:\n                escaped = False\n            elif ln[j-1] == \"\\\\\":\n                escaped = True\n            if skip_till:\n                if char == skip_till and not escaped:\n                    skip_till = \"\"\n                    skip = -1\n            if skip:\n                if skip == -1:\n                    skip = 0\n                continue\n            if char in brackets_start:\n                bracket_stack.append(char)\n            elif char in brackets:\n                if bracket_stack.pop() != brackets[char]:\n                    raise ValueError(\"Mismatching Brackets\")\n\n            if char == \"\\n\" and bracket_stack:\n                # + ln[j+1:] is not required as file is split into lines at \\n\n                file_lns[i] = ln[:j]\n            if char == '\"' and not escaped:\n                skip_till, skip = '\"', 1\n            elif char == \"'\" and not escaped:\n                skip_till, skip = \"'\", 1\n    return file_lns\n"
  },
  "-/from/split_name": {
    "code": "def split(name, **kwargs):\n    parts = []\n    name_parts = []\n    for part in str(name).split(\".\"):\n        parts += [part, \".\"]\n        name_parts += [part]\n    return name_parts, parts[:-1]\n"
  },
  "-/from/standardize": {
    "code": "def standardize(words, state, str_funcs, **kwargs):\n\n    i = 0\n    while i < len(words):\n        word = words[i]\n        if (word.endswith(\"=\") and word != \"==\" and len(word) > 1\n                and word.tok_type == \"assignment_op\"):\n            start = str_funcs.find_start(i-1)\n            words[i:i+1] = str_funcs.get_words(\n                \"={}{}\".format(\" \".join(words[start+1:i]), word[:-1]))\n        if word == \";\" and words[i+1] == \"\\n\":\n            words[i:i+2] = [words[i+1]]\n        if word == \"not\" and words[i+1] == \"in\":\n            not_in_word = state.new_capsule.word(\"not in\", type_=\"operator\")\n            words[i:i+2] = [not_in_word]\n        i += 1\n\n    return words\n"
  },
  "-/from/stmt_classifier": {
    "code": "def classify(stmt, str_funcs, words, new_capsule, **kwargs):\n    kws = [\"if\", \"elif\", \"else\", \"for\", \"while\", \"return\", \"import\"]\n    kw_words = {new_capsule.word(kw, type_=\"name\") for kw in kws}\n\n    detected_type = \"\"\n    kw_index = -1\n    for word in stmt.to_list():\n        if word in kw_words:\n            detected_type = stmt.stmt_type = word\n            kw_index = word.index\n            break\n        elif \"func_stmt\" in word.tags or \"var_stmt\" in word.tags:\n            if \"func_stmt\" in word.tags:\n                usage_type = word.tags[\"func_stmt\"].usage_type\n                detected_type = stmt.stmt_type = f\"func_{usage_type}_stmt\"\n                stmt.func_stmt = word.tags[\"func_stmt\"]\n            else:\n                usage_type = word.tags[\"var_stmt\"].usage_type\n                detected_type = stmt.stmt_type = f\"var_{usage_type}_stmt\"\n                stmt.var_stmt = word.tags[\"var_stmt\"]\n\n    if not detected_type:\n        return\n\n    if detected_type in [\"if\", \"elif\"]:\n        stmt.cond_rng = kw_index+1, stmt.end-1\n    elif detected_type == \"for\":\n\n        def is_rng_for_loop(for_loop):\n            def check():\n                iter_obj = for_loop.iter_obj.to_list()\n                if iter_obj[0] != \"range\":\n                    return False\n                if str_funcs.pair_char(iter_obj, 1)[1] != len(iter_obj) - 1:\n                    return False\n                return True\n            return check\n        stmt.iter_obj = new_capsule.statement(words, kw_index+3, stmt.end-1)\n        stmt.is_rng_for_loop = is_rng_for_loop(stmt)\n"
  },
  "-/from/stmt_structs": {
    "code": "def find_structs(state, **kwargs):\n    conditionals = {\"if\", \"elif\", \"else\"}\n    triggers = []\n    for node in state.stmts.iterate(same_lvl=False, all_=False):\n        base = node.stmt\n        if (triggers and base.start <= triggers[0][0]\n                and (triggers[0][0] <= base.end or base.end == -1)):\n            triggers.pop(0)[1]()\n        if base.stmt_type in conditionals:\n            handle_cond_stmt(base, node)\n        if base.stmt_type == \"if\":\n            handle_elif_ladder(base, node)\n        elif base.stmt_type == \"for\" or base.stmt_type == \"while\":\n            handle_loop_else(base, node)\n        elif (base.stmt_type == \"func_def_stmt\"\n              or base.stmt_type == \"func_call_stmt\"):\n            func = base.func_stmt.func_usages[0].func\n            triggers.insert(index_less_than(triggers, func.body_end),\n                            (func.body_end, future_func_stmt(node)))\n\n\ndef index_less_than(triggers, body_end):\n    low = 0\n    mid = 0\n    high = len(triggers) - 1\n    if body_end < low:\n        raise ValueError(\"Invalid Body End\")\n    while low <= high:\n        mid = (high + low) // 2\n        if triggers[mid][0] < body_end:\n            low = mid + 1\n        elif triggers[mid][0] > body_end:\n            high = mid - 1\n    return mid\n\n\ndef future_func_stmt(base):\n    def run():\n        handle_func_stmt(base)\n    return run\n\n\ndef handle_func_stmt(node):\n    stmt = node.stmt\n    stmt.paths = []\n    stmt.paths, _ = find_paths(node)\n\n\ndef find_paths(node):\n    stmt_ll = node.get_next(False, False).stmt_ll\n    stmts, eos = [stmt_ll], False\n    stmts_iter = stmt_ll.iterate(same_lvl=True, all_=False)\n    for node in stmts_iter:\n        if node.stmt.stmt_type == \"return\":\n            eos = True\n        elif hasattr(node.stmt, \"ladder_count\"):\n\n            def find_path_parts(l_node):\n                path_stmts, path_eos = find_paths(l_node)\n                stmts.append(path_stmts[0])\n                return int(path_eos)\n\n            eos_count = find_path_parts(node)\n            for _ in range(node.stmt.ladder_count):\n                eos_count += find_path_parts(next(stmts_iter))\n\n            if eos_count == node.stmt.ladder_count+1:\n                eos = True\n        if eos:\n            break\n    return stmts, eos\n\n\ndef handle_cond_stmt(stmt, node):\n    next_node = node.get_next(False, False)\n    stmt.cond_stmt = next_node.stmt_ll\n\n\ndef handle_elif_ladder(base, node):\n    ladder_count = 0\n    elif_stmt = None\n    for elif_node in node.stmt_ll.iterate(base, True, False):\n        elif_stmt = elif_node.stmt\n        if elif_stmt.stmt_type != \"elif\":\n            break\n        ladder_count += 1\n    base.is_elif_ladder = (elif_stmt and elif_stmt.stmt_type == \"else\"\n                           or ladder_count > 1)\n    if base.is_elif_ladder:\n        base.ladder_count = int(elif_stmt.stmt_type == \"else\") + ladder_count\n\n\ndef handle_loop_else(base, node):\n    node = node.stmt_ll.get_next_stmt(base, True, False)\n    base.is_else_break = node is not None and node.stmt.stmt_type == \"else\"\n"
  },
  "-/from/tok_type": {
    "code": "def detect_comment(token, **kwargs):\n    if token == \"#\":\n        return \"sl_comment\"\n\n\ndef check_skip(i, string, **kwargs):\n    char = string[i]\n    if string[i:i+3] == '\"\"\"':\n        return '\"\"\"\\n', \"comment\"\n    if char == \"#\":\n        return \"\\n\", \"comment\"\n    if char == '\"':\n        return '\"', \"str\"\n    if char == \"'\":\n        return \"'\", \"str\"\n    return \"\", None\n\n\ndef detect(token, index, str_funcs, words, state, **kwargs):\n    if token in [\"True\", \"False\"]:\n        return \"bool\"\n    if (token != \".\" and all([t.isdecimal() or t in [\".\", \"_\"] for t in token])\n            or token[:2] in [\"0x\", \"0o\", \"0b\"]):\n        return \"float\" if \".\" in token else \"int\"\n    if token == \"None\":\n        return \"None\"\n    if (all(t in str_funcs.ALNUM for t in token)\n            and (token[0].isalpha() or token[0] == \"_\") and token != \"in\"):\n        return \"name\"\n    if token == \";\":\n        return \"stmt_sep\"\n    if token == \"\\n\":\n        return \"stmt_term\"\n    if token == \"#\":\n        return \"sl_comment\"\n    if token == '\"\"\"':\n        return \"docs\"\n    if token in str_funcs.assignment_ops:\n        if token == \"in\":\n            stmt_start_i = str_funcs.find_start(index, words)\n            if stmt_start_i != -1 and words[stmt_start_i+1] == \"for\":\n                return \"assignment_op\"\n        else:\n            return \"assignment_op\"\n    if token in str_funcs.comparison_ops:\n        return \"comparison_op\"\n    if token in str_funcs.matchable:\n        prev_word = words[index-1]\n        reserved = state.database.from_reserved_kw\n        if not(token == \"[\" and\n               (prev_word == \")\" or prev_word == \"]\"\n                or (prev_word.tok_type == \"name\" and prev_word not in\n                    reserved))):\n            return \"pair_start_symbol\"\n    if token in str_funcs.matchable.values():\n        if token == \"]\":\n            _, start = str_funcs.pair_char(words, index)\n            if words[start].tok_type == \"pair_start_symbol\":\n                return \"pair_end_symbol\"\n        else:\n            return \"pair_end_symbol\"\n    if token in str_funcs.ref_ops:\n        return \"ref_op\"\n    if token in str_funcs.operators:\n        return \"operator\"\n    if token in str_funcs.misc_ops:\n        return \"symbol\"\n\n\ndef get_symbols(**kwargs):\n    matchable_ops = {\"(\": \")\", \"[\": \"]\", \"{\": \"}\"}\n    assignment_ops = {\"=\", \"+=\", \"-=\", \"*=\", \"/=\", \"//=\", \"**=\", \"&=\",\n                      \"|=\", \"^=\", \"<<=\", \">>=\", \"%=\", \"in\"}\n    comparison_ops = {\"==\", \"!=\", \">\", \"<\", \">=\", \"<=\", \"<>\"}\n    misc_ops = {\":\", \",\", \"<<\", \">>\"}\n    binary_ops = {\n        \"**\": {\"associativity\": -1},\n        \"/\": {\"associativity\": 1},\n        \"//\": {\"associativity\": 1},\n        \"%\": {\"associativity\": 1},\n        \"*\": {\"associativity\": 1},\n        \"+\": {\"associativity\": 1},\n        \"-\": {\"associativity\": 1},\n        \"==\": {\"associativity\": 1},\n        \"!=\": {\"associativity\": 1},\n        \">\": {\"associativity\": 1},\n        \">=\": {\"associativity\": 1},\n        \"<\": {\"associativity\": 1},\n        \"<=\": {\"associativity\": 1},\n        \"and\": {\"associativity\": 1},\n        \"or\": {\"associativity\": 1},\n        \"in\": {\"associativity\": 1},\n        \"not in\": {\"associativity\": 1}\n    }\n    unary_ops = {\"not\": {\"associativity\": -1, \"doo\": 1},\n                 \"-\": {\"associativity\": 1, \"doo\": 1}}\n    custom_ops = {\"[\": {\"associativity\": 1}, \"not\": {\"associativity\": 1}}\n    ref_ops = {\n        \".\": {\"associativity\": 1},\n        \"[\": {\"associativity\": 1},\n        \"]\": {\"associativity\": 1}\n    }\n    eqn_terminators = {\":\", \",\", \"=\"}\n    # operators = {\"+\", \"-\", \"*\", \"/\", \"^\", \"~\", \"&\", \"|\", \"%\", \"[\", \"]\", \"**\",\n    #              \"//\", \".\", \"in\"}\n    return [matchable_ops, assignment_ops, misc_ops, comparison_ops, unary_ops,\n            binary_ops, ref_ops, custom_ops, eqn_terminators]\n"
  },
  "-/from/var_parser": {
    "code": "def check_set(index, end, str_funcs, words, module_mem, **kwargs):\n    stmt = words[index].tags[\"stmt\"]\n    j = stmt.start\n    start = index\n\n    is_iter_comp = check_iter_comprehension(\n        str_funcs, words, index, module_mem)\n    is_iter_comp = is_iter_comp == 1\n    if (stmt.words[j] != \"for\" and stmt.words[j].tok_type == \"name\"\n            and stmt.words[j+1] == \"(\" and not is_iter_comp):\n        return\n    for i in range(start, end):\n        word = words[i]\n        if word in [\";\", \"\\n\", \":\"]:\n            return\n        elif \"=\" in word and word.tok_type != \"comparison_op\":\n            return {\"usage\": \"set\", \"equals\": i, \"start\": stmt.start,\n                    \"end\": stmt.end, \"call_path\": words[index:i],\n                    \"words_loc\": (index, i)}\n        elif \"in\" == word:\n            if words[stmt.start] == \"for\":\n                return {\"usage\": \"set\", \"equals\": i, \"start\": stmt.start+1,\n                        \"end\": stmt.end-1, \"call_path\": words[index:i],\n                        \"words_loc\": (index, i)}\n            if is_iter_comp:\n                start, end = word.tags[\"lhs\"].start, word.tags[\"rhs\"].end\n                if start <= index < end:\n                    return {\"usage\": \"set\", \"equals\": i, \"start\": start,\n                            \"end\": end, \"call_path\": words[index:i],\n                            \"words_loc\": (index, i)}\n\n\ndef check_get(index, str_funcs, words, module_mem, **kwargs):\n    var_name = str_funcs.get_identifier_name(index)\n    future_dec = check_iter_comprehension(\n        str_funcs, words, index, module_mem, check=True)\n    return {\"usage\": \"get\", \"start\": index, \"end\": var_name + 1,\n            \"call_path\": words[index:var_name+1],\n            \"words_loc\": (index, var_name+1), \"future_dec\": future_dec}\n\n\ndef check_struct(index, str_funcs, words, state, **kwargs):\n    if words[index-1] == \"class\":\n        end = str_funcs.find_end(index)\n        if words[end-1] != \":\":\n            return\n\n        self_obj = state.new_capsule.variable(state, f\"{words[index]}.self\",\n                                              type_from=f\"{words[index]}\")\n        return {\"usage\": \"struct\", \"name\": words[index], \"attrs\": {},\n                \"start\": index-1, \"end\": end+1, \"call_path\": [words[index]],\n                \"words_loc\": (index, index+1), \"self_obj\": self_obj}\n\n\ndef check_iter_comprehension(str_funcs, words, index, module_mem, check=False):\n    stmt = words[index].tags[\"stmt\"]\n\n    in_list = 0\n    is_comp_res = 0\n    is_dec_part = False\n    list_start_i = -1\n    stmt_base_i = stmt[0].index\n    dec_words = []\n    for i, word in enumerate(stmt):\n        if is_dec_part:\n            if word == \"in\":\n                if dec_words[0] == \"(\":\n                    dec_words = dec_words[1:-1]\n                var_indexes = str_funcs.get_collection_queue(dec_words)\n                var_names = [dec_words[rng[0]: rng[1]] for rng in var_indexes]\n                if \"iter_comp_vars\" not in module_mem:\n                    module_mem[\"iter_comp_vars\"] = {}\n                module_mem[\"iter_comp_vars\"][list_start_i] = var_indexes\n                return is_comp_res + in_list\n            if \"pair\" in word.tags:\n                dec_words.extend(word.tags[\"pair_value\"])\n            else:\n                dec_words.append(word)\n        if word == \"[\":\n            in_list = 1\n            list_start_i = i\n            if check is True:\n                return (\"iter_comp_vars\" in module_mem\n                        and i in module_mem[\"iter_comp_vars\"]\n                        and index in module_mem[\"iter_comp_vars\"][i])\n        if in_list and stmt_base_i + i == index:\n            is_comp_res = 1\n        if word == \"for\" and in_list:\n            stmt[i].tags[\"iter_comp\"] = \"list\"\n            start, end = stmt_base_i + list_start_i+1, stmt_base_i + i\n            stmt[i].tags[\"comp_res_rng\"] = range(start, end)\n            is_dec_part = True\n    return 0\n\n\ndef check_body(**kwargs):\n    return check_struct(**kwargs)\n\n\ndef check_no_body(**kwargs):\n    set_res = check_set(**kwargs)\n    if set_res:\n        return set_res\n    return check_get(**kwargs)\n"
  },
  "-/to/func_convert": {
    "code": "def to_str(func_usage, conversions):\n    func = func_usage.func\n    convert = conversions.convert\n    if func_usage.usage_type == \"def\":\n        args = \"\"\n        for arg_name, arg in func.args.items():\n            if (hasattr(arg.value, \"start\")\n                    and arg.value.start != -1 and arg.value.end != -1):\n                converted_val = convert(arg.value.start, arg.value.end)\n                args += \"{}={},\".format(arg_name, converted_val)\n            else:\n                args += \"{},\".format(arg_name)\n\n        if args:\n            args = args[:-1]\n        conv_func = \"{}({})\".format(func.ref_loc, args)\n    else:\n        args_str = \"\"\n        for arg in func_usage.args.values():\n            # TODO: Handle case when argument is default and hence not start\n            # and end exist\n            converted_val = convert(arg.start, arg.end)\n            args_str += str(converted_val) + \",\"\n        conv_func = \"{}({})\".format(func.ref_loc, args_str[:-1])\n    return conv_func\n"
  },
  "valid_paths": [
    "/from/Coll-Bridge/types/float",
    "/from/preprocessor",
    "/from/func_parser",
    "/from/Coll-Bridge/types/None",
    "/from/standardize",
    "/from/defaults",
    "/from/Coll-Bridge/types/int",
    "/from/tok_type",
    "/from/var_parser",
    "/from/Coll-Bridge/types/bool",
    "/from/Coll-Bridge/types/dict",
    "/from/Coll-Bridge/types/tuple",
    "/from/stmt_structs",
    "/to/func_convert",
    "/from/split_name",
    "/from/get_val",
    "/from/Coll-Bridge/types/list",
    "/from/get_type",
    "/from/stmt_classifier",
    "/from/Coll-Bridge/types/str",
    "/from/lib_parser"
  ]
}