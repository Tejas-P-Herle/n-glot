{
  "-/from/Coll-Bridge/types/ArrayList<Integer>": {
    "code": "def operate(state, self, operator, other):\n    if operator == \"[]\" and (other == \"int\" or other == \"double\"):\n        return \"Integer\"\n\n\ndef typecast(state, value, other_type):\n    if other_type.base_eq == \"str\":\n        return f\"{value}.toString()\"\n    return value\n\n\ndef to_str(state, value, **kwargs):\n    var_usage = kwargs.pop(\"var_usage\")\n    var = var_usage.var\n    state.import_lib((\"ArrayList\", \"java.util.ArrayList\"))\n\n    def is_int(elem):\n        return ((hasattr(elem, \"type_\") and elem.type_ == \"int\")\n                or (hasattr(elem, \"tok_type\") and elem.tok_type == \"int\"))\n\n    if var.value is not None and var.value.type_ != \"null\":\n        stmt_end = state.words[var_usage.index].tags[\"stmt\"].end\n        elem_add_lns = [f\"{var_usage.call_path}.add({elem});\"\n                        for elem in var.value if is_int(elem)]\n        state.add_line_after(stmt_end, \"\".join(elem_add_lns))\n    return \"new ArrayList<Integer>()\"\n"
  },
  "-/from/Coll-Bridge/types/ArrayList<Integer[]>": {
    "code": "def operate(state, self, operator, other):\n    if operator == \"[]\" and (other == \"int\" or other == \"double\"):\n        return \"Integer[]\"\n\n\ndef typecast(state, value, other_type):\n    if other_type.base_eq == \"str\":\n        state.import_lib((\"Arrays\", \"java.util.Arrays\"))\n        state.import_lib((\"Collectors\", \"java.util.stream.Collectors\"))\n\n        int_arr_str = f'{value}.stream().map(Arrays::toString)'\n        int_arr_str += f'.collect(Collectors.toList())'\n        arr_list_str = f'\"[\"+String.join(\", \",{int_arr_str})+\"]\"'\n        return f\"{arr_list_str}\"\n    return value\n\n\ndef to_str(value, state, **kwargs):\n    state.import_lib((\"ArrayList\", \"java.util.ArrayList\"))\n\n    var_usage = kwargs[\"var_usage\"]\n    var = var_usage.var\n    str_funcs = state.str_funcs\n    convert_obj = state.conversions.convert_obj\n    if var.value is not None and var.value.type_ != \"null\":\n        stmt_end = state.words[var_usage.index].tags[\"stmt\"].end\n\n        start = var.value[0].index\n        elem_iter = str_funcs.get_element(\n            state.words, start + 1, len(var.value) + start - 1)\n        elements = list(elem_iter)\n        int_list = state.all_types_to[\"Integer[]\"]\n        elem_str = [(state.type_solved_values[elem.start][1]).typecast(\n                     convert_obj(elem), int_list)\n                    for i, elem in enumerate(elements)]\n        elem_add_lns = [\n            f\"{var_usage.call_path}.add({elem});\" for elem in elem_str]\n        state.add_line_after(stmt_end, \"\".join(elem_add_lns))\n    return \"new ArrayList<Integer[]>()\"\n"
  },
  "-/from/Coll-Bridge/types/ArrayList<String>": {
    "code": "def operate(state, self, operator, other):\n    if operator == \"[]\" and (other == \"int\" or other == \"double\"):\n        return \"String\"\n\n\ndef typecast(state, value, other_type):\n    if other_type.base_eq == \"str\":\n        return f\"{value}.toString()\"\n    return value\n\n\ndef get_super_type(self_type, other_type):\n    if other_type.base_eq == \"None\":\n        return self_type\n    return other_type\n\n\ndef var_to_str(state, var_usage):\n    var = var_usage.var\n    state.import_lib((\"ArrayList\", \"java.util.ArrayList\"))\n\n    if var.value[0] == \"[\" and var.value[-1] == \"]\":\n        if var.value is not None and var.value.type_ != \"null\":\n            stmt_end = state.words[var_usage.index].tags[\"stmt\"].end\n            elements = \" \".join(var.value[1:-1]).split(\",\")\n            elem_add_lns = [f\"{var_usage.call_path}.add({elem});\"\n                            for elem in elements if elem.strip()]\n            if elem_add_lns:\n                state.add_line_after(stmt_end, \"\".join(elem_add_lns))\n        return \"new ArrayList<String>()\"\n\n\ndef to_str(state, value, **kwargs):\n    if \"var_usage\" in kwargs:\n        return var_to_str(state, kwargs[\"var_usage\"])\n    return \"new ArrayList<String>()\"\n"
  },
  "-/from/Coll-Bridge/types/Integer": {
    "code": "def operate(state, self, operator, other):\n    return other\n\n\ndef get_super_type(self_type, other_type):\n    return \"Integer\"\n\n\ndef typecast(state, value, other_type):\n    return f\"({other_type}){value}\"\n"
  },
  "-/from/Coll-Bridge/types/Integer[]": {
    "code": "\n\ndef get_super_type(self_type, other_type):\n    if (other_type.base_eq == \"None\" or other_type.base_eq == \"int\"\n            or other_type == \"-Any-\"):\n        return self_type\n    return other_type\n\n\ndef operate(state, self, operator, other):\n    if operator == \"[]\" and (other == \"int\" or other == \"double\"):\n        return \"Integer\"\n\n\ndef is_super_type(sub_type):\n    return False\n\n\ndef to_str(value, state, **kwargs):\n    dec_prefix = kwargs[\"dec_prefix\"] if \"dec_prefix\" in kwargs else False\n    elem_iter = state.str_funcs.get_element(\n        state.words, value.start + 1, len(value) + value.start - 1)\n    elem_add_lns = [f\"{state.conversions.convert_obj(elem)}\"\n                    for elem in elem_iter]\n    if value[0] == \"[\":\n        if not dec_prefix:\n            value = f\"new Integer[] {{{','.join(elem_add_lns)}}}\"\n        else:\n            value = \"{\" + \",\".join(elem_add_lns) + \"}\"\n    else:\n        value = state.conversions.convert_obj(value)\n    return value\n\n\ndef typecast(state, value, other_type):\n    if other_type.base_eq == \"str\":\n        state.import_lib((\"Arrays\", \"java.util.Arrays\"))\n        return f\"Arrays.toString({value})\"\n    return value\n"
  },
  "-/from/Coll-Bridge/types/List<Double>": {
    "code": "def operate(state, self, operator, other):\n    return self\n\n\ndef to_str(state, value, **kwargs):\n    is_list_comp = False\n    comp_res_rng = None\n    for word in value:\n        if word == \"for\" and word.tags[\"iter_comp\"] == \"list\":\n            is_list_comp = True\n            comp_res_rng = word.tags[\"comp_res_rng\"]\n        if word == \"in\" and is_list_comp:\n            rhs = word.tags[\"rhs\"]\n            base_arr = rhs.type_.typecast(\n                state.conversions.convert_obj(rhs),\n                state.all_types_to[\"List<Integer>\"])\n            key_start_word = state.words[word.tags[\"lhs\"].start]\n            comp_key = str(key_start_word.tags[\"var_usage\"].call_path)\n            comp_res = state.conversions.convert(\n                comp_res_rng.start, comp_res_rng.stop)\n            state.import_lib((\"List\", \"java.util.List\"))\n            state.import_lib((\"Collectors\", \"java.util.stream.Collectors\"))\n            res = \"{}.stream().map({}->{}).collect(Collectors.toList())\"\n            return res.format(base_arr, comp_key, comp_res)\n    return state.conversions.convert_obj(value)\n\n\ndef typecast(state, value, other_type):\n    if other_type.base_eq == \"str\":\n        return f\"{value}.toString()\"\n    return f\"({other_type}){value}\"\n"
  },
  "-/from/Coll-Bridge/types/List<Integer>": {
    "code": "def operate(state, self, operator, other):\n    return self\n\n\ndef to_str(state, value, **kwargs):\n    is_list_comp = False\n    comp_res_rng = None\n    for word in value:\n        if word == \"for\" and word.tags[\"iter_comp\"] == \"list\":\n            is_list_comp = True\n            comp_res_rng = word.tags[\"comp_res_rng\"]\n        if word == \"in\" and is_list_comp:\n            rhs = word.tags[\"rhs\"]\n            base_arr = rhs.type_.typecast(\n                state.conversions.convert_obj(rhs),\n                state.all_types_to[\"List<Integer>\"])\n            key_start_word = state.words[word.tags[\"lhs\"].start]\n            comp_key = str(key_start_word.tags[\"var_usage\"].call_path)\n            comp_res = state.conversions.convert(\n                comp_res_rng.start, comp_res_rng.stop)\n            state.import_lib((\"List\", \"java.util.List\"))\n            state.import_lib((\"Collectors\", \"java.util.stream.Collectors\"))\n            res = \"{}.stream().map({}->{}).collect(Collectors.toList())\"\n            return res.format(base_arr, comp_key, comp_res)\n    return state.conversions.convert_obj(value)\n\n\ndef typecast(state, value, other_type):\n    if other_type.base_eq == \"str\":\n        return f\"{value}.toString()\"\n    return f\"({other_type}){value}\"\n"
  },
  "-/from/Coll-Bridge/types/List<String>": {
    "code": "def operate(state, self, operator, other):\n    return self\n\n\ndef get_final_req_vars(words, var):\n    for i, comp_res_word in enumerate(words):\n        if \"var_usage\" in comp_res_word.tags:\n            ref_var_usage = comp_res_word.tags[\"var_usage\"]\n            ref_var = ref_var_usage.var\n            if ref_var != var:\n                yield i, ref_var_usage, ref_var\n\n\ndef get_final_var_name(state, stmt, abs_name):\n    preferred_name = f\"{abs_name}Final\"\n    return state.get_new_obj_name(\n        stmt.start - 2, [preferred_name], preferred_name)\n\n\ndef dec_final_var(state, stmt, ref_var, ref_var_usage):\n    final_var_name = get_final_var_name(state, stmt, ref_var.abs_name)\n    final_dec = \"final {} {}={};\".format(\n        ref_var.type_, final_var_name,\n        ref_var_usage.call_path)\n    state.add_line_before(stmt.start, final_dec)\n\n    return state.new_capsule.variable(\n        state, final_var_name, type_to=ref_var.type_,\n        type_from=ref_var.type_from\n    )\n\n\ndef get_final_vars(state, words, stmt, var, final_vars):\n    for i, ref_var_usage, ref_var in get_final_req_vars(words, var):\n        if ref_var not in final_vars:\n            final_vars[ref_var] = dec_final_var(\n                state, stmt, ref_var, ref_var_usage)\n        ref_var_usage.change_obj(final_vars[ref_var])\n        state.scope.add_to_all_scopes(\n            final_vars[ref_var],\n            cond=lambda s: s.matches([ref_var], [final_vars[ref_var]]))\n        yield i, ref_var_usage, ref_var\n\n\ndef declare_finals(state, words, stmt, var, final_vars):\n    list(get_final_vars(state, words, stmt, var, final_vars))\n\n\ndef replace_finals(state, words, stmt, var, final_vars):\n    for i, ref_var_usage, ref_var in get_final_vars(\n            state, words, stmt, var, final_vars):\n        words[i] = final_vars[ref_var].abs_name\n\n\ndef to_str(state, value, **kwargs):\n    is_list_comp = False\n    comp_res_rng = None\n\n    for word in value:\n        if word == \"for\" and word.tags[\"iter_comp\"] == \"list\":\n            is_list_comp = True\n            comp_res_rng = word.tags[\"comp_res_rng\"]\n        if word == \"in\" and is_list_comp:\n            rhs = word.tags[\"rhs\"]\n            base_arr = state.conversions.convert_obj(rhs)\n            if not str(rhs.type_).startswith(\"List\"):\n                type_set = [state.get_eq_type(type_, state.TYPE)\n                            for type_ in rhs.type_from.info[\"type_set\"]]\n                list_type = sum(type_set, start=next(iter(type_set)))\n                if list_type in [\"int\", \"char\", \"float\", \"double\"]:\n                    list_type += state.all_types_to[\"null\"]\n                base_arr = rhs.type_.typecast(\n                    base_arr, state.all_types_to[f\"List<{list_type}>\"])\n            key_start_word = state.words[word.tags[\"lhs\"].start]\n            comp_key = str(key_start_word.tags[\"var_usage\"].call_path)\n            var = key_start_word.tags[\"var_usage\"].var\n            stmt = word.tags[\"stmt\"]\n            outer_scope_var = state.find_in_scope(\n                comp_key, stmt.start-2, throw_error=False)\n            if outer_scope_var is not None:\n                comp_key = state.get_new_obj_name(\n                    stmt.start-2, [comp_key], comp_key)\n                var.rename(comp_key, all_traces=True)\n            comp_res_words = state.words[comp_res_rng.start:comp_res_rng.stop]\n            final_vars = {}\n            declare_finals(state, comp_res_words, stmt, var, final_vars)\n            comp_res = state.conversions.convert(\n                comp_res_rng.start, comp_res_rng.stop)\n            state.import_lib((\"List\", \"java.util.List\"))\n            state.import_lib((\"Collectors\", \"java.util.stream.Collectors\"))\n            map_str = \"{}.stream().map({}->{})\".format(\n                base_arr, comp_key, comp_res)\n            comp_end = value[0].index+len(value)\n            filter_str = \"\"\n            for j in range(word.index, comp_end):\n                word_if = state.words[j]\n                if word_if == \"if\":\n                    filter_words = state.words[word_if.index+1:comp_end-1]\n                    replace_finals(state, filter_words, stmt, var, final_vars)\n                    snippet = \" \".join(filter_words)\n                    filter_cond = state.convert_snippet(\n                        f\"bool({snippet})\", word_if.index+1)\n                    filter_str = \".filter({}->{})\".format(\n                        comp_key, filter_cond)\n            collect = \".collect(Collectors.toList())\"\n            return map_str + filter_str + collect\n    return \"new ArrayList<String>()\"\n\n\ndef typecast(state, value, other_type):\n    if other_type.base_eq == \"str\":\n        return f\"{value}.toString()\"\n    return f\"({other_type}){value}\"\n"
  },
  "-/from/Coll-Bridge/types/Map-Entry<String,Map<String,String>>": {
    "code": "def operate(state, self, operator, other):\n    if operator == \"[]\":\n        if operator.tags[\"pair_value\"] == [\"0\"]:\n            return \"String\"\n        return \"Map<String,String>\"\n    return \"void\"\n\n\ndef get_super_type(self_type, other_type):\n    if str(other_type).startswith(\"Pair\"):\n        return self_type\n    return other_type\n\n\ndef typecast(state, value, other_type):\n    return f\"({other_type}){value}\"\n"
  },
  "-/from/Coll-Bridge/types/Map-Entry<String,String>": {
    "code": "def operate(state, self, operator, other):\n    if operator == \"[]\":\n        return \"String\"\n    return \"void\"\n\n\ndef get_super_type(self_type, other_type):\n    if str(other_type).startswith(\"Pair\"):\n        return self_type\n    return other_type\n\n\ndef typecast(state, value, other_type):\n    return f\"({other_type}){value}\"\n"
  },
  "-/from/Coll-Bridge/types/Map.Entry<String,Map<String,String>>": {
    "code": "def operate(self, operator, other):\n    if operator == \"[]\":\n        if operator.tags[\"pair_value\"] == [\"0\"]:\n            return \"String\"\n        return \"Map<String,String>\"\n    return \"void\"\n\n\ndef get_super_type(self_type, other_type):\n    return other_type\n\n\ndef typecast(state, value, other_type):\n    return f\"({other_type}){value}\"\n"
  },
  "-/from/Coll-Bridge/types/Map.Entry<String,String>": {
    "code": "def operate(self, operator, other):\n    if operator == \"[]\":\n        return \"String\"\n    return \"void\"\n\n\ndef get_super_type(self_type, other_type):\n    return other_type\n\n\ndef typecast(state, value, other_type):\n    return f\"({other_type}){value}\"\n"
  },
  "-/from/Coll-Bridge/types/Map<String,Map<String,String>>": {
    "code": "\ndef to_str(value, state, **kwargs):\n    type_info = value.type_from.info\n    types = [state.get_eq_type(type_, state.TYPE)\n             for type_ in type_info[\"types\"]]\n    var_usage = kwargs[\"var_usage\"] if \"var_usage\" in kwargs else \"ERROR\"\n    state.import_lib((\"Map\", \"java.util.Map\"))\n    value_rng = (value.start, value.end)\n    if (value_rng in state.range_flags\n            and \"is_const\" in state.range_flags[value_rng]):\n        state.import_lib((\"HashMap\", \"java.util.HashMap\"))\n        convert = state.conversions.convert\n        keys_str = [convert(key.start, key.end) for key in type_info[\"keys\"]]\n        values_str = [convert(val.start, val.end)\n                      for val in type_info[\"values\"]]\n        puts = \"\".join(f\"{var_usage.call_path}.put({key},{value});\"\n                       for key, value in zip(keys_str, values_str))\n        state.add_line_after(value.end, puts)\n        return f\"new HashMap<{types[0]}, {types[1]}>() {{}}\"\n    else:\n        return state.conversions.convert_obj(value)\n\n\ndef obj_usg_to_str(state, value, obj_usage):\n    if state.check_CPC_flag(\"IterConv\", obj_usage.call_path):\n        return str(value) + \".keySet()\"\n    return str(value)\n"
  },
  "-/from/Coll-Bridge/types/Map<String,String>": {
    "code": "def operate(state, self, operator, other):\n    if operator == \"[]\":\n        return \"String\"\n    return \"void\"\n\n\ndef to_str(value, state, **kwargs):\n    type_info = value.type_from.info\n    types = [state.get_eq_type(type_, state.TYPE)\n             for type_ in type_info[\"types\"]]\n    var_usage = kwargs[\"var_usage\"] if \"var_usage\" in kwargs else \"ERROR\"\n    state.import_lib((\"Map\", \"java.util.Map\"))\n    value_rng = (value.start, value.end)\n    if (value_rng in state.range_flags\n            and \"is_const\" in state.range_flags[value_rng]):\n        state.import_lib((\"HashMap\", \"java.util.HashMap\"))\n        convert = state.conversions.convert\n        keys_str = [convert(key.start, key.end) for key in type_info[\"keys\"]]\n        values_str = [convert(val.start, val.end)\n                      for val in type_info[\"values\"]]\n        puts = \"\".join(f\"{var_usage.call_path}.put({key},{value});\"\n                       for key, value in zip(keys_str, values_str))\n        state.add_line_after(value.end, puts)\n        return f\"new HashMap<{types[0]}, {types[1]}>() {{}}\"\n    else:\n        return state.conversions.convert_obj(value)\n\n\ndef obj_usg_to_str(state, value, obj_usage):\n    if state.check_CPC_flag(\"IterConv\", obj_usage.call_path):\n        return str(value) + \".keySet()\"\n    return str(value)\n"
  },
  "-/from/Coll-Bridge/types/Matcher": {
    "code": "def operate(state, self, operator, other):\n    return \"void\"\n\n\ndef get_super_type(self_type, other_type):\n    return other_type\n\n\ndef typecast(state, value, other_type):\n    if other_type.base_eq == \"bool\":\n        return f\"({value}).find()\"\n    return f\"({other_type}){value}\"\n"
  },
  "-/from/Coll-Bridge/types/Object[]": {
    "code": "\n\ndef typecast(state, value, other_type):\n    if other_type.base_eq == \"str\":\n        state.import_lib((\"Arrays\", \"java.util.Arrays\"))\n        return f\"Arrays.toString({value})\"\n    if other_type.base_eq == \"bool\":\n        value_str = f\"({value})\" if len(value) > 1 else f\"{value}\"\n        return f\"{value_str}.length == 0\"\n    return value\n\n\ndef get_super_type(self_type, other_type):\n    return other_type\n\n\ndef to_str(value, state, **kwargs):\n    dec_prefix = kwargs[\"dec_prefix\"] if \"dec_prefix\" in kwargs else False\n    if value[0] != \"[\" or value[-1] != \"]\":\n        return state.conversions.convert(value.start, value.end)\n    elem_iter = state.str_funcs.get_element(\n        state.words, value.start + 1, value.start + len(value) - 1)\n\n    elem_add_lns = [f\"{state.conversions.convert_obj(elem)}\"\n                    for elem in elem_iter]\n    if value[0] == \"[\":\n        if not dec_prefix:\n            value = f\"new Object[] {{{','.join(elem_add_lns)}}}\"\n        else:\n            value = \"{\" + \",\".join(elem_add_lns) + \"}\"\n    else:\n        value = state.conversions.convert_obj(value)\n    return value\n\n\n"
  },
  "-/from/Coll-Bridge/types/Pattern": {
    "code": "def operate(state, self, operator, other):\n    return \"void\"\n\n\ndef get_super_type(self_type, other_type):\n    return other_type\n\n\ndef typecast(state, value, other_type):\n    return f\"({other_type}){value}\"\n"
  },
  "-/from/Coll-Bridge/types/String": {
    "code": "def operate(state, self, operator, other):\n    if operator in [\"in\", \"not in\", \"or\", \"not\"]:\n        return \"boolean\"\n    if operator == \"[]\" and (other == \"int\" or other == \"double\"):\n        return \"char\"\n    return \"String\"\n\n\ndef get_super_type(self_type, other_type):\n    return \"String\"\n\n\ndef typecast(state, value, other_type):\n    if other_type.base_eq == \"int\":\n        return f\"Integer.parseInt({value})\"\n    if other_type == \"Integer\":\n        return f\"Integer.valueOf({value})\"\n    if other_type.base_eq == \"bool\":\n        return f\"!{value}.isEmpty()\"\n    return f\"({other_type}){value}\"\n\n\ndef obj_usg_to_str(state, value, obj_usage):\n    if state.check_CPC_flag(\"IterConv\", obj_usage.call_path):\n        return str(value) + \".toCharArray()\"\n    return str(value)\n"
  },
  "-/from/Coll-Bridge/types/String[]": {
    "code": "\n\ndef operate(state, self, operator, other):\n    if operator == \"[]\" and (other == \"int\" or other == \"double\"):\n        return \"String\"\n    if operator == \"not\":\n        return \"boolean\"\n    return \"String[]\"\n\n\ndef typecast(state, value, other_type):\n    if other_type.base_eq == \"str\":\n        state.import_lib((\"Arrays\", \"java.util.Arrays\"))\n        return f\"Arrays.toString({value})\"\n    if other_type.base_eq == \"bool\":\n        value_str = f\"({value})\" if len(value) > 1 else f\"{value}\"\n        return f\"{value_str}.length == 0\"\n    if other_type == \"List<String>\":\n        state.import_lib((\"Arrays\", \"java.util.Arrays\"))\n        state.import_lib((\"ArrayList\", \"java.util.ArrayList\"))\n        return f\"(new ArrayList<String>(Arrays.asList({value})))\"\n    return value\n\n\ndef get_super_type(self_type, other_type):\n    if other_type == \"String\":\n        return \"\"\n    return self_type\n\n\ndef to_str(value, state, **kwargs):\n    dec_prefix = kwargs[\"dec_prefix\"] if \"dec_prefix\" in kwargs else False\n    if value[0] != \"[\" or value[-1] != \"]\":\n        return state.conversions.convert(value.start, value.end)\n    elem_iter = state.str_funcs.get_element(\n        state.words, value.start + 1, value.start + len(value) - 1)\n\n    elem_add_lns = [f\"{state.conversions.convert_obj(elem)}\"\n                    for elem in elem_iter]\n    if value[0] == \"[\":\n        if not dec_prefix:\n            value = f\"new String[] {{{','.join(elem_add_lns)}}}\"\n        else:\n            value = \"{\" + \",\".join(elem_add_lns) + \"}\"\n    else:\n        value = state.conversions.convert_obj(value)\n    return value\n\n\n"
  },
  "-/from/Coll-Bridge/types/boolean": {
    "code": "def operate(state, self, operator, other):\n    return \"boolean\"\n\n\ndef get_super_type(self_type, other_type):\n    return \"boolean\"\n\n\ndef is_super_type(sub_type):\n    return False\n\n\ndef typecast(state, value, other_type):\n    if other_type == \"String\":\n        return f\"String.valueOf({value})\"\n    return f\"({other_type}){value}\"\n"
  },
  "-/from/Coll-Bridge/types/char": {
    "code": "\ndef operate(state, self, operator, other):\n    if operator == \"in\":\n        if other == \"String\":\n            return \"boolean\"\n\n\ndef get_operate_typecast(state, opr, other_types):\n    if opr == \"==\" and other_types[0] == \"String\":\n        return \"String\"\n\n\ndef typecast(state, value, other_type):\n    if other_type == \"int\":\n        return f\"Character.getNumericValue({value})\"\n    if other_type == \"String\":\n        return f\"Character.toString({value})\"\n"
  },
  "-/from/Coll-Bridge/types/double": {
    "code": "def operate(state, self, operator, other):\n    return \"float\"\n\n\ndef get_super_type(self_type, other_type):\n    if other_type.base_eq == \"float\":\n        return \"float\"\n    if other_type == \"null\":\n        return \"Double\"\n    return \"float\"\n\n\ndef is_super_type(sub_type):\n    return sub_type == \"int\"\n\n\ndef typecast(state, value, other_type):\n    return f\"({other_type}){value}\"\n"
  },
  "-/from/Coll-Bridge/types/double[]": {
    "code": "\n\ndef to_str(value, state, **kwargs):\n    dec_prefix = kwargs[\"dec_prefix\"] if \"dec_prefix\" in kwargs else False\n    elem_iter = state.str_funcs.get_element(\n        state.words, value.start + 1, len(value) + value.start - 1)\n    elem_add_lns = [f\"{state.conversions.convert_obj(elem)}\"\n                    for elem in elem_iter]\n    if value[0] == \"[\":\n        if not dec_prefix:\n            value = f\"new double[] {{{','.join(elem_add_lns)}}}\"\n        else:\n            value = \"{\" + \",\".join(elem_add_lns) + \"}\"\n    else:\n        value = state.conversions.convert_obj(value)\n    return value\n\n\ndef get_super_type(self_type, other_type):\n    return \"int[]\"\n\n\ndef operate(state, self, operator, other):\n    if operator == \"[]\" and (other == \"int\" or other == \"double\"):\n        return \"double\"\n\n\ndef typecast(state, value, other_type):\n    if other_type.base_eq == \"str\":\n        state.import_lib((\"Arrays\", \"java.util.Arrays\"))\n        return f\"Arrays.toString({value})\"\n    elif other_type == \"List<Double>\":\n        state.import_lib((\"DoubleStream\", \"java.util.stream.DoubleStream\"))\n        conv_code = (\"DoubleStream.of({}).boxed().collect(\" +\n                     \"Collectors.toCollection(ArrayList::new))\")\n        return conv_code.format(value)\n    return value\n"
  },
  "-/from/Coll-Bridge/types/int": {
    "code": "# other must be a Type\ndef operate(state, self, operator: str, other):\n    if other is None:\n        return \"int\"\n    if operator == \"/\" and other == \"int\":\n        return \"float\"\n    if operator == \"in\":\n        return \"boolean\"\n    if operator == \"**\":\n        return \"float\"\n    return other\n\n\ndef get_operate_typecast(state, opr, other_types):\n    if opr == \"==\" and other_types[0] == \"String\":\n        return \"String\"\n\n\n# sub_type can be a string or a Type\ndef is_super_type(sub_type):\n    return False\n\n\n# self_type and other_type can be a string or a Type\ndef get_super_type(self_type, other_type):\n    if other_type.base_eq == \"float\":\n        return \"float\"\n    if other_type == \"null\":\n        return \"Integer\"\n    if other_type == \"Integer\":\n        return \"Integer\"\n    if other_type == \"String\":\n        return \"String\"\n    return \"int\"\n\n\n# other_type can be a string or a Type\ndef typecast(state, value: str, other_type):\n    if other_type.base_eq == \"str\":\n        return f\"String.valueOf({value})\"\n    if other_type.base_eq == \"bool\":\n        return f\"{value} != 0\"\n    if other_type == \"Integer\":\n        return value\n    return f\"({other_type}){value}\"\n"
  },
  "-/from/Coll-Bridge/types/int[]": {
    "code": "\n\ndef get_super_type(self_type, other_type):\n    if (other_type.base_eq == \"None\" or other_type.base_eq == \"int\"\n            or other_type == \"-Any-\"):\n        return self_type\n    return other_type\n\n\ndef operate(state, self, operator, other):\n    if operator == \"[]\" and (other == \"int\" or other == \"double\"):\n        return \"int\"\n\n\ndef is_super_type(sub_type):\n    return False\n\n\ndef to_str(state, value, **kwargs):\n    dec_prefix = kwargs[\"dec_prefix\"] if \"dec_prefix\" in kwargs else False\n    elem_iter = state.str_funcs.get_element(\n        state.words, value.start + 1, len(value) + value.start - 1)\n    elem_add_lns = [f\"{state.conversions.convert_obj(elem)}\"\n                    for elem in elem_iter]\n    if value[0] == \"[\":\n        if not dec_prefix:\n            value = f\"new int[] {{{','.join(elem_add_lns)}}}\"\n        else:\n            value = \"{\" + \",\".join(elem_add_lns) + \"}\"\n    else:\n        value = state.conversions.convert_obj(value)\n    return value\n\n\ndef typecast(state, value, other_type):\n    if other_type.base_eq == \"str\":\n        state.import_lib((\"Arrays\", \"java.util.Arrays\"))\n        return f\"Arrays.toString({value})\"\n    elif other_type == \"Integer[]\":\n        if value.startswith(\"new int[]\"):\n            return \"new Integer[]\" + value[9:]\n    elif other_type == \"List<Integer>\":\n        state.import_lib((\"IntStream\", \"java.util.stream.IntStream\"))\n        conv_code = (\"IntStream.of({}).boxed().collect(\" +\n                     \"Collectors.toCollection(ArrayList::new))\")\n        return conv_code.format(value)\n    return value\n"
  },
  "-/from/Coll-Bridge/types/int[][]": {
    "code": "\n\ndef get_super_type(self_type, other_type):\n    if (other_type.base_eq == \"None\" or other_type.base_eq == \"int\"\n            or other_type == \"-Any-\"):\n        return self_type\n    return other_type\n\n\ndef operate(state, self, operator, other):\n    if operator == \"[]\" and (other == \"int\" or other == \"double\"):\n        return \"int[]\"\n\n\ndef is_super_type(sub_type):\n    return False\n\n\ndef typecast(state, value, other_type):\n    if other_type.base_eq == \"str\":\n        state.import_lib((\"Arrays\", \"java.util.Arrays\"))\n        return f\"Arrays.toString({value})\"\n    return value\n\n\ndef to_str(value, state, **kwargs):\n    dec_prefix = kwargs[\"dec_prefix\"] if \"dec_prefix\" in kwargs else False\n    elem_iter = state.str_funcs.get_element(\n        state.words, value.start + 1, len(value) + value.start - 1)\n    elem_add_lns = [f\"{state.conversions.convert_obj(elem)}\"\n                    for elem in elem_iter]\n    if value[0] == \"[\":\n        if not dec_prefix:\n            value = f\"new int[][] {{{','.join(elem_add_lns)}}}\"\n        else:\n            value = \"{\" + \",\".join(elem_add_lns) + \"}\"\n    else:\n        value = state.conversions.convert_obj(value)\n    return value\n"
  },
  "-/from/Coll-Bridge/types/null": {
    "code": "def operate(state, self, operator, other):\n    return \"None\"\n\n\ndef get_super_type(self_type, other_type):\n    if other_type == \"int\":\n        return \"Integer\"\n    return other_type\n\n\ndef typecast(state, value, other_type):\n    return f\"({other_type}){value}\"\n"
  },
  "-/from/Coll-Bridge/types/re-Match": {
    "code": "def operate(self, operator, other):\n    return \"void\"\n\n\ndef get_super_type(self_type, other_type):\n    return other_type\n\n\ndef typecast(state, value, other_type):\n    return f\"({other_type}){value}\"\n"
  },
  "-/from/Coll-Bridge/types/re.Pattern": {
    "code": "def operate(self, operator, other):\n    return \"void\"\n\n\ndef get_super_type(self_type, other_type):\n    return other_type\n\n\ndef typecast(state, value, other_type):\n    return f\"({other_type}){value}\"\n"
  },
  "-/from/Coll-Bridge/types/void": {
    "code": "def operate(state, self, operator, other):\n    return \"void\"\n\n\ndef get_super_type(self_type, other_type):\n    return other_type\n\n\ndef typecast(state, value, other_type):\n    return f\"({other_type}){value}\"\n"
  },
  "-/from/get_type": {
    "code": "def solve_types(value, str_funcs, state, words, **kwargs):\n\n    # If value is empty, return None type\n    all_types = state.all_types_from\n    if not value or value == [None]:\n        return all_types[\"None\"]\n\n    str_funcs.solve_type(value)\n\n    if len(value) == 1:\n        value = value[0]\n        if value.__class__.__name__ != \"Type\":\n            raise TypeError(\"Unable to Detect Type of '{}'\".format(value))\n    else:\n        raise TypeError(\"Unable to Detect Type of '{}'\".format(value))\n\n    return value\n\n\ndef run_func_ops(op, i, val, all_types):\n    if op == \".\":\n        handle_dot_op(i, val, all_types)\n\n\ndef handle_dot_op(i, val, all_types):\n    len_val = len(val)\n    j = i\n    while len_val > j + 2 and val[j+2] == \".\":\n        j += 2\n\n    lhs = val[i].tags[\"lhs\"][0]\n    if \"var_usage\" in lhs.tags:\n        obj = lhs.tags[\"var_usage\"].obj\n        type_ = obj.type_from\n    elif \"obj_usage\" in lhs.tags:\n        obj = lhs.tags[\"obj_usage\"].obj\n        type_ = obj.type_from\n    elif \"func_usage\" in lhs.tags:\n        obj = lhs.tags[\"func_usage\"].func\n        type_ = obj.get_type_from()\n    elif \"const\" in lhs.tags:\n        type_ = all_types[lhs.tags[\"const\"]]\n    else:\n        raise ValueError(\"Unable to detect type of LHS\")\n    # val[i-1:j+2] = [type_]\n    val.solve_operator(i-1, j+2, type_)\n\n\ndef custom_ops(state, val, i, all_types):\n    op = val[i]\n    if op == \"[\":\n        rhs, rhs_end = state.str_funcs.pair_char(val, i)\n\n        lhs_rng = (i-1, i)\n        rhs_rng = (i+1, rhs_end+1)\n\n        bracket_word = state.new_capsule.word(\"[]\", type_=val[i].tok_type)\n        bracket_word.tags = val[i].tags\n        bracket_word.index = val[i].index\n        res_type_str = val[i-1].get_opr_res(bracket_word, val[i+1])\n        res_type = all_types[res_type_str]\n        # val[lhs_rng[0]:rhs_rng[1]] = [res_type]\n        val.solve_operator(lhs_rng[0], rhs_rng[1], res_type)\n\n\ndef in_assignment(all_types):\n    return all_types[\"bool\"]\n\n\ndef for_in_assignment(var, type_, all_types):\n\n    if str(type_).endswith(\"[]\"):\n        return all_types[str(type_)[:-2]]\n    if type_ == \"IntStream\":\n        return all_types[\"int\"]\n    if type_ == \"String\":\n        return all_types[\"char\"]\n    if type_ == \"Map.entrySet\":\n        prev_var = var.value[0].tags[\"func_usage\"].call_path[-2]\n        map_types = prev_var.type_.info[\"types\"]\n        map_entry_type = all_types[f\"Map.Entry<{map_types[0]},{map_types[1]}>\"]\n        map_entry_type.info[\"types\"] = map_types\n        return map_entry_type\n    if str(type_).startswith(\"Map\"):\n        if \"types\" in type_.info and type_.info[\"types\"]:\n            return type_.info[\"types\"][0]\n\n\ndef assignment_stmt_mod(state, type_, words, var, all_types):\n    assignment_type = var.assignment_type\n    value = var.value\n    if assignment_type == \"in\":\n        if words[value.start].tags[\"stmt\"].stmt_type == \"for\":\n            return for_in_assignment(var, type_, all_types)\n    return type_\n"
  },
  "-/to/Coll-Bridge/python/Coll-Bridge/eq_types/-Any-": {
    "code": "def get_eq_type(state, obj, obj_type, **kwargs):\n    if obj_type == state.FUNC:\n        return \"void\"\n    return \"null\"\n"
  },
  "-/to/Coll-Bridge/python/Coll-Bridge/eq_types/None": {
    "code": "def get_eq_type(obj, **kwargs):\n    return \"null\"\n"
  },
  "-/to/Coll-Bridge/python/Coll-Bridge/eq_types/bool": {
    "code": "def get_eq_type(obj, **kwargs):\n    return \"boolean\"\n"
  },
  "-/to/Coll-Bridge/python/Coll-Bridge/eq_types/dict": {
    "code": "def get_eq_type(state, obj, obj_type, **kwargs):\n    from_type = obj if obj_type == state.TYPE else obj.get_type_from()\n    key, value = from_type.info[\"types\"]\n    key_eq = state.get_eq_type(key, state.TYPE)\n    value_eq = state.get_eq_type(value, state.TYPE)\n    return f\"Map<{key_eq},{value_eq}>\"\n"
  },
  "-/to/Coll-Bridge/python/Coll-Bridge/eq_types/dict_items": {
    "code": "def get_eq_type(**kwargs):\n    return \"Map.entrySet\"\n"
  },
  "-/to/Coll-Bridge/python/Coll-Bridge/eq_types/float": {
    "code": "def get_eq_type(obj, **kwargs):\n    return \"double\"\n"
  },
  "-/to/Coll-Bridge/python/Coll-Bridge/eq_types/int": {
    "code": "def get_eq_type(state, obj, obj_type, **kwargs):\n    return \"int\"\n"
  },
  "-/to/Coll-Bridge/python/Coll-Bridge/eq_types/io-TextIOWrapper": {
    "code": "def get_eq_type(obj, **kwargs):\n    return \"File\"\n"
  },
  "-/to/Coll-Bridge/python/Coll-Bridge/eq_types/list": {
    "code": "def get_eq_type(state, obj, obj_type, **kwargs):\n    type_from = obj if obj_type == state.TYPE else obj.get_type_from()\n    if \"type_set\" not in type_from.info:\n        return \"Object[]\"\n\n    type_set_to = [state.get_eq_type(type_, state.TYPE)\n                   for type_ in type_from.info[\"type_set\"]]\n    if not type_set_to:\n        return \"Object[]\"\n    super_type = state.get_super_type(type_set_to)\n\n    if super_type is not None and super_type != \"null\":\n        cls_type = super_type\n        if super_type in [\"int\", \"char\", \"float\", \"double\"]:\n            cls_type = super_type + state.all_types_to[\"null\"]\n        if ((\"iter_comp\" in type_from.info and type_from.info[\"iter_comp\"])\n                or \"List\" in type_from.flags):\n            return f\"List<{cls_type}>\"\n        if ((\"is_dynamic\" in type_from.info and type_from.info[\"is_dynamic\"])\n                or \"ArrayList\" in type_from.flags):\n            return f\"ArrayList<{cls_type}>\"\n        return f\"{super_type}[]\"\n    return \"Object[]\"\n"
  },
  "-/to/Coll-Bridge/python/Coll-Bridge/eq_types/range": {
    "code": "def get_eq_type(obj, **kwargs):\n    return \"IntStream\"\n"
  },
  "-/to/Coll-Bridge/python/Coll-Bridge/eq_types/re-Match": {
    "code": "def get_eq_type(state, **kwargs):\n    state.import_lib((\"Pattern\", \"java.util.regex.Matcher\"))\n    return \"Matcher\"\n"
  },
  "-/to/Coll-Bridge/python/Coll-Bridge/eq_types/re-Pattern": {
    "code": "def get_eq_type(state, **kwargs):\n    state.import_lib((\"Pattern\", \"java.util.regex.Pattern\"))\n    return \"Pattern\"\n"
  },
  "-/to/Coll-Bridge/python/Coll-Bridge/eq_types/str": {
    "code": "def get_eq_type(state, obj, obj_type, **kwargs):\n    type_from = obj if obj_type == state.TYPE else obj.get_type_from()\n    if \"length\" in type_from.info and type_from.info[\"length\"] == 1:\n        return \"char\"\n    return \"String\"\n"
  },
  "-/to/Coll-Bridge/python/Coll-Bridge/eq_types/tuple": {
    "code": "def get_eq_type(state, obj, obj_type, **kwargs):\n    type_from = obj if obj_type == state.TYPE else obj.get_type_from()\n    if type_from.info[\"elem_count\"] == 2:\n        elem_types_to = [state.get_eq_type(type_, state.TYPE)\n                         for type_ in type_from.info[\"types\"]]\n        if (\"cause\" in type_from.info\n                and type_from.info[\"cause\"] == \"dict_items\"):\n            state.import_lib((\"Map\", \"java.util.Map\"))\n            return f\"Map.Entry<{elem_types_to[0]},{elem_types_to[1]}>\"\n        state.import_lib((\"Pair\", \"javafx.util.Pair\"))\n        return f\"Pair<{elem_types_to[0]},{elem_types_to[1]}>\"\n    raise NotImplementedError(\"Not all Tuple Eq Types Implemented\")\n"
  },
  "-/to/Coll-Bridge/python/Coll-Bridge/func_call/new_const": {
    "code": "def match(func_usage, **kwargs):\n    if func_usage.call_path[-1].abs_name == \"__init__\":\n        return (func_usage.start, range(func_usage.start, func_usage.end),\n                {\"func_usage\": func_usage})\n\n\ndef get_dat(func_usage, **kwargs):\n    return \"new \" + func_usage.call_path.get_str(cond=lambda i, p: p.is_struct)\n",
    "priority": 1
  },
  "-/to/Coll-Bridge/python/Coll-Bridge/keyword_triggers/not": {
    "code": "def match(word, **kwargs):\n    convs = [(word.index, range(word.index, word.index+1),\n              {\"word\": word, \"opr_capsule\": None, \"direct\": True})]\n    if \"opr_capsule\" in word.tags:\n        opr_capsule = word.tags[\"opr_capsule\"]\n        convs.append(\n            (word.index, range(opr_capsule.start, opr_capsule.end),\n             {\"word\": word, \"opr_capsule\": opr_capsule, \"direct\": False})\n        )\n    return convs\n\n\ndef to_str(word, opr_capsule, state, direct, **kwargs):\n\n    if direct:\n        return \"!\"\n\n    start, end = opr_capsule.terms_rng[0]\n    code_snippet = \"bool({})\".format(\" \".join(state.words[start:end]))\n\n    converted_code = state.convert_snippet(code_snippet, word.index)\n    if \" \" not in converted_code:\n        return \"!{}\".format(converted_code)\n    return \"!({})\".format(converted_code)\n"
  },
  "-/to/Coll-Bridge/python/Coll-Bridge/lib_convs/Coll-Bridge/dict/items": {
    "code": "def get_sign(state, **kwargs):\n    return state.FUNC, ((\"dict_items\", tuple()),)\n\n\ndef to_str(obj_usage, state, convert_obj, **kwargs):\n    call_path = obj_usage.call_path\n    dict_obj = str(call_path.get_str_till(len(call_path)-1))\n    return f\"{dict_obj}.entrySet()\"\n"
  },
  "-/to/Coll-Bridge/python/Coll-Bridge/lib_convs/Coll-Bridge/list/append": {
    "code": "def get_sign(state, **kwargs):\n    args = ((\"object\", \"-Any-\"),)\n    return state.FUNC, ((\"None\", args),)\n\n\ndef modify(obj_usage, **kwargs):\n    list_obj = obj_usage.obj.ref_loc[-2]\n    list_obj.get_type_from()\n    list_obj.type_from.info[\"type_set\"].append(obj_usage.args[0].type_from)\n    list_obj.type_from.info[\"is_dynamic\"] = True\n\n\ndef to_str(obj_usage, state, convert_obj, **kwargs):\n    state.import_lib((\"ArrayList\", \"java.util.ArrayList\"))\n    call_path = obj_usage.call_path\n    arraylist_obj = str(call_path.get_str_till(len(call_path)-1))\n    arg = obj_usage.args[0]\n    arg_str = arg.type_.typecast(\n        convert_obj(arg), state.all_types_to[str(call_path[-2].type_)[10:-1]])\n    return f\"{arraylist_obj}.add({arg_str})\"\n"
  },
  "-/to/Coll-Bridge/python/Coll-Bridge/lib_convs/Coll-Bridge/list/extend": {
    "code": "def get_sign(state, **kwargs):\n    args = ((\"object\", \"-Any-\"),)\n    return state.FUNC, ((\"None\", args),)\n\n\ndef to_str(obj_usage, state, convert_obj, **kwargs):\n    state.import_lib((\"ArrayList\", \"java.util.ArrayList\"))\n    call_path = obj_usage.call_path\n    arraylist_obj = str(call_path.get_str_till(len(call_path)-1))\n    arg = obj_usage.args[0]\n    if not arg.type_solved:\n        state.solve_type(arg)\n    type_sets = []\n    if \"type_set\" in arg.type_.info:\n        type_sets += arg.type_.info[\"type_set\"]\n    if \"type_set\" in call_path[-2].type_.info:\n        type_sets += call_path[-2].type_.info[\"type_set\"]\n    arg_str = arg.type_.typecast(\n        convert_obj(arg), arg.type_ + call_path[-2].type_)\n    return f\"{arraylist_obj}.addAll({arg_str})\"\n"
  },
  "-/to/Coll-Bridge/python/Coll-Bridge/lib_convs/Coll-Bridge/os/Coll-Bridge/path/isfile": {
    "code": "def get_sign(state, **kwargs):\n    args_list = ((\"file\", \"String\", \"str\"),)\n    return state.FUNC, (((\"boolean\", \"bool\"), args_list),)\n\n\ndef to_str(obj_usage, state, convert_obj, **kwargs):\n    return \"(new File({})).exists()\".format(convert_obj(obj_usage.args[0]))\n"
  },
  "-/to/Coll-Bridge/python/Coll-Bridge/lib_convs/Coll-Bridge/os/Coll-Bridge/path/split": {
    "code": "def get_sign(state, **kwargs):\n    args = ((\"p\", \"str\"),)\n    list_type = state.all_types_from[\"list\"].copy()\n    list_type.info[\"type_set\"] = [state.all_types_from[\"str\"]]\n    return state.FUNC, ((list_type, args),)\n\n\ndef to_str(obj_usage, state, convert_obj, **kwargs):\n    state.import_lib((\"File\", \"java.io.File\"))\n    state.import_lib((\"Pattern\", \"java.util.regex.Pattern\"))\n    conv_format = \"{}.split(Pattern.quote(File.separator))\"\n\n    return conv_format.format(convert_obj(obj_usage.args[0]))\n"
  },
  "-/to/Coll-Bridge/python/Coll-Bridge/lib_convs/Coll-Bridge/os/Coll-Bridge/path/splitext": {
    "code": "def get_sign(state, **kwargs):\n    args = ((\"p\", \"str\"),)\n    list_type = state.all_types_from[\"list\"]\n    list_type.info[\"type_set\"] = [state.all_types_from[\"str\"]]\n    return state.FUNC, ((list_type, args),)\n\n\ndef to_str(obj_usage, state, convert_obj, **kwargs):\n    filepath = convert_obj(obj_usage.args[0])\n    if \"splitext\" not in state.nglot_funcs:\n        add_splitext_func(state)\n    return \"{}.splitext({})\".format(state.helper_class_name, filepath)\n\n\ndef add_splitext_func(state):\n    fn_body = (\"int lastDot=filename.lastIndexOf(\\\".\\\");return new String[]{\"\n               + \"filename.substring(0,lastDot),filename.substring(lastDot)};\")\n    splitext_func = (\"public static String[]splitext(String filename){\"\n                     + fn_body + \"}\")\n    state.add_nglot_func(\"splitext\", splitext_func)\n"
  },
  "-/to/Coll-Bridge/python/Coll-Bridge/lib_convs/Coll-Bridge/os/path": {
    "code": "def get_sign(state, **kwargs):\n    return state.MODULE,\n\n\ndef to_str(obj_usage, state, convert_obj, **kwargs):\n    return \"-TODO-\"\n"
  },
  "-/to/Coll-Bridge/python/Coll-Bridge/lib_convs/Coll-Bridge/re/Coll-Bridge/Match/span": {
    "code": "def get_sign(state, **kwargs):\n    args = ((\"group\", \"int\"),)\n    return state.FUNC, ((\"tuple\", args),)\n\n\ndef to_str(obj_usage, state, convert_obj, **kwargs):\n    state.import_lib((\"*\", \"java.util.regex.*\"))\n    state.import_lib((\"Pair\", \"org.javatuples.Pair\"))\n    matcher = obj_usage.call_path.get_str_till(len(\n        obj_usage.call_path) - 1)\n    state.add_line_before(state.words[obj_usage.start].tags[\"stmt\"].start-1,\n                          \"{}.find();\".format(matcher))\n    return \"Pair.with({0}.start(), {0}.end())\".format(matcher)\n"
  },
  "-/to/Coll-Bridge/python/Coll-Bridge/lib_convs/Coll-Bridge/re/Pattern": {
    "code": "def get_sign(state, **kwargs):\n    return state.STRUCT, \"struct\"\n"
  },
  "-/to/Coll-Bridge/python/Coll-Bridge/lib_convs/Coll-Bridge/re/compile": {
    "code": "def get_sign(state, **kwargs):\n    args_list = ((\"pattern\", \"str\"),)\n    return state.FUNC, ((\"re.Pattern\", args_list),)\n\n\ndef to_str(obj_usage, state, convert_obj, **kwargs):\n    state.import_lib((\"*\", \"java.util.regex.*\"))\n    return \"Pattern.compile({})\".format(convert_obj(obj_usage.args[0]))\n"
  },
  "-/to/Coll-Bridge/python/Coll-Bridge/lib_convs/Coll-Bridge/re/search": {
    "code": "def get_sign(state, **kwargs):\n    args = ((\"pattern\", \"re.Pattern\"), (\"string\", \"str\"))\n    return state.FUNC, ((\"re.Match\", args),)\n\n\ndef to_str(obj_usage, state, convert_obj, **kwargs):\n    state.import_lib((\"*\", \"java.util.regex.*\"))\n    pattern_obj = (obj_usage.args[\"pattern\"] if \"pattern\" in obj_usage.args\n                   else obj_usage.args[0])\n    str_obj = (obj_usage.args[\"string\"] if \"string\" in obj_usage.args\n               else obj_usage.args[1])\n    pattern, string = convert_obj(pattern_obj), convert_obj(str_obj)\n    return \"{}.matcher({})\".format(pattern, string)\n"
  },
  "-/to/Coll-Bridge/python/Coll-Bridge/lib_convs/Coll-Bridge/str/find": {
    "code": "def get_sign(state, **kwargs):\n    args = ((\"sub\", \"str\"), (\"start\", \"int\"), (\"end\", \"int\"))\n    sign_a = (\"int\", args)\n    return state.FUNC, (sign_a,)\n\n\ndef to_str(obj_usage, convert_obj, **kwargs):\n    str_ref = obj_usage.call_path.get_str_till(len(obj_usage.call_path) - 1)\n    arg_sub = convert_obj(obj_usage.args[0])\n    opt_args = \"\"\n    start_arg = None\n    if \"start\" in obj_usage.args:\n        start_arg = convert_obj(obj_usage.args[\"start\"])\n    elif len(obj_usage.args) > 1:\n        start_arg = convert_obj(obj_usage.args[1])\n    if start_arg is not None:\n        opt_args += \",\" + start_arg\n\n    end_arg = None\n    if \"end\" in obj_usage.args:\n        end_arg = convert_obj(obj_usage.args[\"end\"])\n    elif len(obj_usage.args) > 2:\n        end_arg = convert_obj(obj_usage.args[2])\n\n    if end_arg:\n        if start_arg is None:\n            start_arg = \"0\"\n        return \"{}.substring({},{}).indexOf({})\".format(\n            str_ref, start_arg, end_arg, arg_sub)\n    return \"{}.indexOf({}{})\".format(str_ref, arg_sub, opt_args)\n"
  },
  "-/to/Coll-Bridge/python/Coll-Bridge/lib_convs/Coll-Bridge/str/format": {
    "code": "def get_sign(state, **kwargs):\n    args_to = ((\"arg-n\", \"str\"),)\n    sign_a = (\"str\", args_to)\n    return state.FUNC, (sign_a,)\n\n\ndef to_str(obj_usage, state, convert_obj, **kwargs):\n    str_ref = obj_usage.call_path.get_str_till(len(obj_usage.call_path) - 1)\n    args_str = \",\".join(convert_obj(arg) for arg in obj_usage.args.values())\n    return \"String.format({},{})\".format(str_ref, args_str)\n"
  },
  "-/to/Coll-Bridge/python/Coll-Bridge/lib_convs/Coll-Bridge/str/lower": {
    "code": "def get_sign(state, **kwargs):\n    return state.FUNC, ((\"str\", tuple()),)\n\n\ndef to_str(obj_usage, state, convert_obj, **kwargs):\n    conv_format = \"{}.toLowerCase()\"\n    return conv_format.format(obj_usage.call_path.get_str_till(len(\n        obj_usage.call_path)-1))\n"
  },
  "-/to/Coll-Bridge/python/Coll-Bridge/lib_convs/Coll-Bridge/str/lstrip": {
    "code": "def get_sign(state, **kwargs):\n    args = ((\"chars\", \"list\"),)\n    sign_a = (\"str\", args)\n    return state.FUNC, (sign_a,)\n\n\ndef to_str(obj_usage, **kwargs):\n    if len(obj_usage.args) != 0:\n        raise NotImplementedError(\"lstrip char set not implemented\")\n    return \"{}.stripLeading()\".format(obj_usage.call_path.get_str_till(len(\n        obj_usage.call_path)-1))\n"
  },
  "-/to/Coll-Bridge/python/Coll-Bridge/lib_convs/Coll-Bridge/str/rsplit": {
    "code": "def get_sign(state, **kwargs):\n    args_to = ((\"sep\", \"str\"), (\"maxsplit\", \"int\"))\n    list_type = state.all_types_from[\"list\"].copy(True)\n    list_type.info[\"type_set\"] = [state.all_types_from[\"str\"]]\n    sign_a = (list_type, args_to)\n    return state.FUNC, (sign_a,)\n\n\ndef to_str(obj_usage, state, convert_obj, **kwargs):\n    sep, maxsplit = obj_usage.args[0][0], obj_usage.args[1][0]\n    obj_call_path = obj_usage.call_path.get_str_till(\n        len(obj_usage.call_path)-1)\n\n    if \"rsplit\" not in state.nglot_funcs:\n        add_rsplit_func(state)\n    return \"{}.rsplit({}, {}, {})\".format(\n        state.helper_class_name, obj_call_path, sep, maxsplit)\n\n\ndef add_rsplit_func(state):\n    state.import_lib((\"List\", \"java.util.List\"))\n    state.import_lib((\"ArrayList\", \"java.util.ArrayList\"))\n    var_dec = (\"List<String>splitString=new ArrayList<String>();\"\n               + \"int prevEnd=base.length();\")\n    class_init = \"RSplitHelpers(){sepCharArray=sep.toCharArray();}\"\n    sep_found = (\"public boolean sepFound(char baseChar){\"\n                 + \"for(char sepChar:this.sepCharArray)if(baseChar==sepChar)\"\n                 + \"return true;return false;}\")\n    class_dec = \"class RSplitHelpers{{char[]sepCharArray;{}{}}}\".format(\n        class_init, sep_found)\n    obj_init = \"RSplitHelpers rsplitHelpers=new RSplitHelpers();\"\n    split_loop = (\"for(int i=base.length()-1;i!=0&&maxsplit!=0;i--) {\"\n                  + \"if(rsplitHelpers.sepFound(base.charAt(i))){\"\n                  + \"splitString.add(0,base.substring(i+1,prevEnd));\"\n                  + \"prevEnd=i;maxsplit-=1;}}\")\n    return_res = (\"if (prevEnd>1)splitString.add(0,base.substring(0,prevEnd));\"\n                  + \"return splitString.toArray(new String[0]);\")\n\n    rsplit_func = (\"public static String[]\"\n                   + \"rsplit(String base,String sep,int maxsplit) {\"\n                   + var_dec + class_dec + obj_init + split_loop + return_res\n                   + \"}\")\n    state.add_nglot_func(\"rsplit\", rsplit_func)\n"
  },
  "-/to/Coll-Bridge/python/Coll-Bridge/lib_convs/Coll-Bridge/str/rstrip": {
    "code": "def get_sign(state, **kwargs):\n    args = ((\"chars\", \"list\"),)\n    sign_a = (\"str\", args)\n    return state.FUNC, (sign_a,)\n\n\ndef to_str(obj_usage, **kwargs):\n    if len(obj_usage.args) != 0:\n        raise NotImplementedError(\"rstrip char set not implemented\")\n    return \"{}.stripTrailing()\".format(obj_usage.call_path.get_str_till(len(\n        obj_usage.call_path)-1))\n"
  },
  "-/to/Coll-Bridge/python/Coll-Bridge/lib_convs/Coll-Bridge/str/split": {
    "code": "def get_sign(state, **kwargs):\n    list_type = state.all_types_from[\"list\"].copy()\n    list_type.info[\"type_set\"] = [state.all_types_from[\"str\"]]\n    args_to = ((\"sep\", \"str\"), (\"maxsplit\", \"int\"))\n    sign_a = (list_type, args_to)\n    return state.FUNC, (sign_a,)\n\n\ndef to_str(obj_usage, convert_obj, **kwargs):\n    opt_args = \"\"\n    maxsplit = (obj_usage.args[\"maxsplit\"] if \"maxsplit\" in obj_usage.args\n                else None)\n    if maxsplit is None and len(obj_usage.args) > 1:\n        maxsplit = obj_usage.args[1]\n    if maxsplit is not None:\n        opt_args += convert_obj(maxsplit)\n    return \"{}.split({})\".format(obj_usage.call_path.get_str_till(len(\n        obj_usage.call_path)-1), opt_args)\n"
  },
  "-/to/Coll-Bridge/python/Coll-Bridge/lib_convs/Coll-Bridge/str/strip": {
    "code": "def get_sign(state, **kwargs):\n    args_to = ((\"chars\", \"list\"),)\n    sign_a = (\"str\", args_to)\n    return state.FUNC, (sign_a,)\n\n\ndef to_str(obj_usage, **kwargs):\n    if len(obj_usage.args) != 0:\n        raise NotImplementedError(\"strip char set not implemented\")\n    return \"{}.strip()\".format(obj_usage.call_path.get_str_till(len(\n        obj_usage.call_path)-1))\n"
  },
  "-/to/Coll-Bridge/python/Coll-Bridge/lib_convs/bool": {
    "code": "def get_sign(state, **kwargs):\n    # arg_index, arg_name, arg_rng, arg_type\n    args = ((\"x\", \"-Any-\"),)\n    return state.FUNC, ((\"bool\", args),)\n\n\ndef to_str(obj_usage, state, convert_obj, **kwargs):\n    arg_type = obj_usage.args[0].type_\n    converted_arg = convert_obj(obj_usage.args[0])\n    return arg_type.typecast(converted_arg, state.all_types_to[\"bool\"])\n"
  },
  "-/to/Coll-Bridge/python/Coll-Bridge/lib_convs/int": {
    "code": "def get_sign(state, **kwargs):\n    # arg_name, arg_type\n    args = ((\"x\", \"-Any-\"),)\n    return state.FUNC, ((\"int\", args),)\n\n\ndef to_str(obj_usage, state, convert_obj, **kwargs):\n    arg_type = obj_usage.args[0].type_\n    return arg_type.typecast(convert_obj(obj_usage.args[0]),\n                             state.all_types_to[\"int\"])\n"
  },
  "-/to/Coll-Bridge/python/Coll-Bridge/lib_convs/len": {
    "code": "def get_sign(state, **kwargs):\n    # arg_index, arg_name, arg_rng, arg_type\n    args = ((\"obj\", \"-Any-\"),)\n    proto_a = (\"int\", args)\n    return state.FUNC, (proto_a,)\n\n\ndef to_str(obj_usage, convert_obj, **kwargs):\n    str_arg_0 = convert_obj(obj_usage.args[0])\n    if obj_usage.args[0].type_.base_eq == \"str\":\n        return \"{}.length()\".format(str_arg_0)\n    return \"{}.length\".format(str_arg_0)\n"
  },
  "-/to/Coll-Bridge/python/Coll-Bridge/lib_convs/list": {
    "code": "def get_sign(state, **kwargs):\n    # arg_index, arg_name, arg_rng, arg_type\n    args = ((\"iterable\", \"-Any-\"),)\n    return state.FUNC, ((\"str\", args),)\n\n\ndef get_req_type(state, type_, attr, usage):\n    if attr.abs_name == \"append\":\n        append_arg = usage.args[0]\n        if type_ == \"list\":\n            type_.info[\"type_set\"].append(append_arg.get_type_from())\n            return\n        else:\n            list_type = state.all_types_from[\"list\"].copy(True)\n            list_type.info[\"type_set\"].append(append_arg.get_type_from())\n            return list_type\n    if attr.abs_name == \"extend\":\n        return\n\n\ndef to_str(obj_usage, state, convert_obj, **kwargs):\n    arg_type = obj_usage.args[0].type_\n    return arg_type.typecast(convert_obj(obj_usage.args[0]),\n                             state.all_types_to[\"str\"])\n"
  },
  "-/to/Coll-Bridge/python/Coll-Bridge/lib_convs/max": {
    "code": "def get_sign(state, **kwargs):\n    # arg_index, arg_name, arg_rng, arg_type\n    args_list = ((\"obj\", \"list\"),)\n    proto_a = (\"int\", args_list)\n\n    args_list = ((\"obj_a\", \"int\"), (\"obj_b\", \"int\"))\n    proto_b = (\"int\", args_list)\n    return state.FUNC, (proto_a, proto_b)\n\n\ndef to_str(obj_usage, state, convert_obj, **kwargs):\n\n    if len(obj_usage.args) == 1:\n        arg_arr = obj_usage.args[0]\n        arg_arr_str = convert_obj(arg_arr)\n\n        if arg_arr.type_ == \"int[]\":\n            new_name = state.get_new_obj_name(arg_arr.index)\n            arr_obj_str = f\"ArrayUtils.toObject({arg_arr_str})\"\n            state.import_lib((\"Collections\", \"java.util.Collections\"))\n            state.add_line_before(\n                obj_usage.start,\n                f\"{new_name}=Arrays.asList({arr_obj_str});\"\n            )\n            arg_arr_str = new_name\n\n        state.import_lib((\"Arrays\", \"java.util.Arrays\"))\n        return f\"Collections.max({arg_arr_str})\"\n    elif len(obj_usage.args) == 2:\n        args = obj_usage.args\n        if args[0].type_ == args[1].type_ == \"int\":\n            state.import_lib((\"Math\", \"java.lang.Math\"))\n            return f\"Math.max({convert_obj(args[0])}, {convert_obj(args[1])})\"\n"
  },
  "-/to/Coll-Bridge/python/Coll-Bridge/lib_convs/min": {
    "code": "def get_sign(state, **kwargs):\n    # arg_index, arg_name, arg_rng, arg_type\n    args = ((\"obj\", \"list\"),)\n    proto_a = (\"int\", args)\n\n    args = ((\"obj_a\", \"int\"), (\"obj_b\", \"int\"))\n    proto_b = (\"int\", args)\n    return state.FUNC, (proto_a, proto_b)\n\n\ndef to_str(obj_usage, state, convert_obj, **kwargs):\n\n    if len(obj_usage.args) == 1:\n        arg_arr = obj_usage.args[0]\n        arg_arr_str = convert_obj(arg_arr)\n\n        if arg_arr.type_ == \"int[]\":\n            new_name = state.get_new_obj_name(arg_arr.index)\n            arr_obj_str = f\"ArrayUtils.toObject({arg_arr_str})\"\n            state.import_lib((\"Collections\", \"java.util.Collections\"))\n            state.add_line_before(\n                obj_usage.start,\n                f\"{new_name}=Arrays.asList({arr_obj_str});\"\n            )\n            arg_arr_str = new_name\n\n        state.import_lib((\"Arrays\", \"java.util.Arrays\"))\n        return f\"Collections.min({arg_arr_str})\"\n    elif len(obj_usage.args) == 2:\n        args = obj_usage.args\n        if args[0].type_ == args[1].type_ == \"int\":\n            state.import_lib((\"Math\", \"java.lang.Math\"))\n            return f\"Math.min({convert_obj(args[0])}, {convert_obj(args[1])})\"\n"
  },
  "-/to/Coll-Bridge/python/Coll-Bridge/lib_convs/not": {
    "code": "def get_sign(state, **kwargs):\n    # arg_index, arg_name, arg_rng, arg_type\n    args = ((\"x\", \"-Any-\", \"-Any-\"),)\n    return state.FUNC, (((\"boolean\", \"bool\"), args),)\n\n\ndef to_str(obj_usage, state, convert_obj, **kwargs):\n    arg_type = obj_usage.args[0].type_\n    converted_arg = convert_obj(obj_usage.args[0])\n    print(\"I RAN\")\n    return \"!({})\".format(\n        arg_type.typecast(converted_arg, state.all_types_to[\"bool\"]))\n"
  },
  "-/to/Coll-Bridge/python/Coll-Bridge/lib_convs/os": {
    "code": "def get_sign(state, **kwargs):\n    return state.STRUCT, \"module\"\n\n\ndef to_str(**kwargs):\n    raise NotImplementedError(\"Unknown Conversion Request\")\n"
  },
  "-/to/Coll-Bridge/python/Coll-Bridge/lib_convs/pow": {
    "code": "def get_sign(state, new_capsule, **kwargs):\n    # arg_index, arg_name, arg_rng, arg_type\n    mod_default = [new_capsule.word(\"None\", type_=\"None\")]\n    mod_arg = {\"ref_loc\": \"mod\", \"value\": mod_default, \"type_from\": \"int\"}\n\n    args = ((\"base\", \"float\"), (\"exp\", \"float\"), mod_arg)\n    proto_a = (\"float\", args)\n\n    args = ((\"base\", \"float\"), (\"exp\", \"int\"), mod_arg)\n    proto_b = (\"float\", args)\n\n    return state.FUNC, (proto_a, proto_b)\n\n\ndef to_str(obj_usage, state, convert_obj, **kwargs):\n    return \"Math.pow({},{})\".format(\n        convert_obj(obj_usage.args[0]), convert_obj(obj_usage.args[1]))\n"
  },
  "-/to/Coll-Bridge/python/Coll-Bridge/lib_convs/print": {
    "code": "\ndef get_sign(state, new_capsule, **kwargs):\n    end_val = [new_capsule.word('\"\\\\n\"', type_=\"str\")]\n    end_arg = {\"ref_loc\": \"end\", \"value\": end_val, \"type_from\": \"str\"}\n\n    sep_val = [new_capsule.word('\" \"', type_=\"str\")]\n    sep_arg = {\"ref_loc\": \"sep\", \"value\": sep_val, \"type_from\": \"str\"}\n\n    file_val = [new_capsule.word(\"sys.stdout\", type_=\"name\")]\n    file_arg = {\"ref_loc\": \"file\", \"value\": file_val,\n                \"type_from\": \"io.TextIOWrapper\"}\n\n    flush_val = [new_capsule.word(\"False\", type_=\"bool\")]\n    flush_arg = {\"ref_loc\": \"flush\", \"value\": flush_val, \"type_from\": \"bool\"}\n\n    args = ((\"arg-n\", \"str\"), end_arg, sep_arg, file_arg, flush_arg)\n\n    return state.FUNC, ((\"None\", args),)\n\n\ndef func_conv(state, obj_usage, convert, **kwargs):\n    if \"flush\" in obj_usage.args:\n        flush_val = obj_usage.args.pop(\"flush\")\n        if flush_val == [\"True\"]:\n            state.add_line_after(obj_usage.end, \";System.out.flush()\")\n        else:\n            cond = convert(flush_val.start, flush_val.end)\n            conditional_flush = f\";if({cond})System.out.flush()\"\n            state.add_line_after(obj_usage.end, conditional_flush)\n\n    if \"%\" in obj_usage.args[0]:\n        return printf_c_format(state, obj_usage)\n    if len(obj_usage.args) > 1:\n        return printf(state, obj_usage)\n    return println(state, obj_usage, convert)\n\n\ndef printf_c_format(state, obj_usage):\n    name = \"System.out.printf\"\n    arg_iter = iter(obj_usage.args.values())\n    arg_0 = next(arg_iter)\n    split_i = arg_0.index(\"%\")\n    end, end_arg = '\"\\\\n\"', None\n    if \"end\" in obj_usage.args:\n        end_arg = obj_usage.args.pop(\"end\")\n        end = str(state.conversions.convert(end_arg.start, end_arg.end))\n    new_arg_0 = state.conversions.convert(arg_0.start, arg_0.start+split_i)\n    extra_args = []\n    args = [\n        new_arg_0[:-1]+f'{parse_str(state, end_arg, end, extra_args)}\"',\n        state.conversions.convert(arg_0.start+split_i+1, arg_0.end)\n    ]\n    args.extend(extra_args)\n    lib = \"\"\n    return name, args, lib\n\n\ndef println(state, func_usage, convert):\n    arg = list(func_usage.args.values())[0]\n    name = \"System.out.println\"\n    arg_type = state.get_eq_type(arg.type_from, state.TYPE)\n    value = str(convert(arg.start, arg.end))\n    basic_types = state.str_funcs.basic_types.union({\"Integer\", \"Double\"})\n    arg_base_type = arg_type if arg_type.base_eq is None else arg_type.base_eq\n    arg_str = (value if arg_base_type in basic_types\n               else arg_type.typecast(value, state.all_types_to[\"str\"], False))\n    if arg_str is None:\n        arg_str = value\n    return name, [arg_str], []\n\n\ndef printf(state, obj_usage):\n    args = []\n    format_str = \"\\\"\"\n\n    end, end_arg, sep, sep_arg = '\"\\\\n\"', None, '\" \"', None\n    if \"end\" in obj_usage.args:\n        end_arg = obj_usage.args.pop(\"end\")\n        end = str(state.conversions.convert(end_arg.start, end_arg.end))\n    if \"sep\" in obj_usage.args:\n        sep_arg = obj_usage.args.pop(\"sep\")\n        sep = str(state.conversions.convert(sep_arg.start, sep_arg.end))\n\n    for arg in obj_usage.args.values():\n        arg_str = str(state.conversions.convert(arg.start, arg.end))\n        format_str += parse_str(state, arg, arg_str, args)\n        format_str += parse_str(state, sep_arg, sep, args)\n\n    args.insert(0, format_str[:-1]+f'{parse_str(state, end_arg, end, args)}\"')\n    name = \"System.out.printf\"\n    lib = \"\"\n    return name, args, lib\n\n\ndef parse_str(state, arg_, str_, args):\n    arg_type = \"String\" if arg_ is None else str(arg_.type_from)\n    if str_[0] == str_[-1] and str_[0] in ['\"', \"'\"]:\n        return str(str_)[1:-1]\n    elif arg_type == \"int\" or arg_type == \"Integer\":\n        args.append(arg_)\n        return \"%d\"\n    elif arg_type == \"float\" or arg_type == \"double\":\n        args.append(arg_)\n        return \"%f\"\n    elif arg_type == \"String\":\n        args.append(arg_)\n        return \"%s\"\n    args.append(arg_.type_.typecast(state.conversions.convert_obj(arg_),\n                                    state.all_types_to[\"str\"]))\n    return \"%s\"\n"
  },
  "-/to/Coll-Bridge/python/Coll-Bridge/lib_convs/range": {
    "code": "def get_sign(state, new_capsule, **kwargs):\n    # arg_index, arg_name, arg_rng, arg_type\n    start_val = [new_capsule.word(\"0\", type_=\"int\")]\n    start_arg = {\"ref_loc\": \"start\", \"value\": start_val, \"type_from\": \"int\"}\n\n    step_val = [new_capsule.word(\"1\", type_=\"int\")]\n    step_arg = {\"ref_loc\": \"step\", \"value\": step_val, \"type_from\": \"int\"}\n\n    args = (start_arg, (\"stop\", \"int\"), step_arg)\n    return state.FUNC, ((\"range\", args),)\n\n\ndef to_str(obj_usage, state, convert_obj, **kwargs):\n    state.import_lib((\"IntStream\", \"java.util.stream.IntStream\"))\n    return \"IntStream.range({},{})\".format(\n        convert_obj(obj_usage.args[0]), convert_obj(obj_usage.args[1]))\n"
  },
  "-/to/Coll-Bridge/python/Coll-Bridge/lib_convs/re": {
    "code": "def get_sign(state, **kwargs):\n    return state.MODULE, \"module\"\n\n\ndef to_str(**kwargs):\n    raise NotImplementedError(\"Unknown Conversion Request\")\n"
  },
  "-/to/Coll-Bridge/python/Coll-Bridge/lib_convs/str": {
    "code": "def get_sign(state, **kwargs):\n    # arg_index, arg_name, arg_rng, arg_type\n    args = ((\"object\", \"-Any-\"),)\n    return state.FUNC, ((\"str\", args),)\n\n\ndef to_str(obj_usage, state, convert_obj, **kwargs):\n    arg_type = obj_usage.args[0].type_\n    to_str_type = state.all_types_to[\"str\"]\n    casted_value = arg_type.typecast(\n        convert_obj(obj_usage.args[0]), to_str_type)\n\n    return to_str_type.to_str(obj_usage, casted_value, raise_error=False)\n"
  },
  "-/to/Coll-Bridge/python/Coll-Bridge/misc/for": {
    "code": "def match(words, index, str_funcs, state, **kwargs):\n    if words[index] == \"for\":\n        stmt = words[index].tags[\"stmt\"]\n        if words[stmt.end-1] == \":\":\n            end = stmt.end + 1\n            if not stmt.is_rng_for_loop():\n                end += 1\n            return index, range(index, end), {\"start\": index, \"end\": end}\n\n\ndef to_str(start, end, convert, convert_obj, words, state, **kwargs):\n\n    var_name = words[start+1]\n    stmt = words[start].tags[\"stmt\"]\n    if stmt.is_rng_for_loop():\n        range_usage = words[start + 3].tags[\"func_usage\"]\n        if len(range_usage.args) == 1:\n            end = convert_obj(range_usage.args[0])\n            return f\"for(int {var_name}=0;{var_name}<{end};{var_name}++)\"\n        elif len(range_usage.args) == 2:\n            start, end = [convert(arg.start, arg.end)\n                          for arg in range_usage.args.values()]\n            return f\"for(int {var_name}={start};{var_name}<{end};{var_name}++)\"\n        elif len(range_usage.args) == 3:\n            start, end, step = [convert(arg.start, arg.end)\n                                for arg in range_usage.args.values()]\n            return (f\"for(int {var_name}={start};{var_name}<{end};\" +\n                    f\"{var_name}+={step})\")\n    elif (\"var_usage\" in words[start+3].tags\n            or \"func_usage\" in words[start+3].tags):\n\n        if \"var_usage\" in words[start+3].tags:\n            iterable = words[start+3].tags[\"var_usage\"]\n        else:\n            iterable = words[start+3].tags[\"func_usage\"]\n        state.set_CPC_info(\"IterConv\", iterable.call_path)\n        iterable_str = convert_obj(iterable)\n        iter_var = words[start+1].tags[\"var_usage\"].var\n        return f\"for({iter_var.type_} {var_name}:{iterable_str}){{\"\n    # elif words[start+3].tags[\"value\"].type_.base_eq == \"str\":\n    #     iter_var = words[start+1].tags[\"var_usage\"].var\n\n    #     iterable_str = convert(start+3, words[start].tags[\"stmt\"].end-1)\n    #     return f\"for(char{iter_var.abs_name}:{iterable_str}.toCharArray()){{\"\n    else:\n        iter_var = words[start+1].tags[\"var_usage\"].var\n\n        iter_words = \"\".join(words[start+3:words[start].tags[\"stmt\"].end-1])\n        iter_len = state.convert_snippet(f\"len({iter_words})\", end-1)\n        state.convert_snippet(f\"{var_name}_count = 0\", start - 1)\n        iter_get_attr = state.convert_snippet(\n            f\"{iter_words}[{var_name}_count]\", end)\n        return (\n            f\"{iter_var.type_} {iter_var.abs_name};for(int {var_name}_count=0;\"\n            + f\"{var_name}_count<{iter_len};{var_name}_count++){{\"\n            + f\"{var_name}={iter_get_attr};\"\n        )\n\n    return \"\"\n",
    "priority": 1
  },
  "-/to/Coll-Bridge/python/Coll-Bridge/misc/if": {
    "code": "def match(words, index, str_funcs, state, **kwargs):\n    if words[index] in [\"if\", \"elif\", \"else\"]:\n        end = words[index].tags[\"stmt\"].end\n        if words[end-1] == \":\":\n            end += 1\n            return index, range(index, end), {\"start\": index, \"end\": end}\n\n\ndef to_str(start, end, convert, words, state, new_capsule, **kwargs):\n    kw = words[start]\n    stmt = kw.tags[\"stmt\"]\n    if kw == \"else\":\n        prev_body = state.get_level_prev_body(start)\n        if prev_body.endswith(\"if\"):\n            return kw\n        else:\n            prev_body_index = int(prev_body.split(\" \")[0])\n            prev_body = words[prev_body_index:start-2]\n            break_word = new_capsule.word(\"break\", type_=\"name\")\n            for break_ in filter(lambda w: w == break_word, prev_body):\n                state.add_line_before(break_.index, \"break_bool=true;\")\n            state.add_line_before(prev_body_index, \"boolean break_bool=false;\")\n            return f\"if(!break_bool)\"\n\n    cond_str = \" \".join(words[i] for i in range(*stmt.cond_rng))\n    cond = state.convert_snippet(f\"bool({cond_str})\", stmt.start)\n    if kw == \"elif\":\n        kw = \"else if\"\n    return f\"{kw}({cond})\"\n",
    "priority": 1
  },
  "-/to/Coll-Bridge/python/Coll-Bridge/misc/operator": {
    "code": "def match(words, index, **kwargs):\n    match_res = []\n    if \"root_opr_capsule\" in words[index].tags:\n        opr_capsule = words[index].tags[\"root_opr_capsule\"]\n        match_res.append(\n            (opr_capsule.start, range(opr_capsule.start, opr_capsule.end),\n             {\"opr_capsule\": opr_capsule}))\n    if \"opr_capsule\" in words[index].tags:\n        opr_capsule = words[index].tags[\"opr_capsule\"]\n        match_res.append(\n            (opr_capsule.start, range(opr_capsule.start, opr_capsule.end),\n             {\"opr_capsule\": opr_capsule}))\n    if match_res:\n        return match_res\n\n\ndef to_str(state, opr_capsule, convert, **kwargs):\n    return solve_capsule(state, opr_capsule, convert, True)\n\n\ndef get_str_wrapper(state, convert):\n    def get_term_str(term):\n        if isinstance(term, slice):\n            return convert(term.start, term.stop)\n        return solve_capsule(state, term, convert)\n\n    def get_opr_str(opr_word):\n        try:\n            return convert(opr_word.index, opr_word.index + 1)\n        except state.errors.ConversionFailed:\n            return opr_word\n\n    def get_typecasts(terms_rng, opr):\n        term_types = []\n        for term_rng in terms_rng:\n            term_types.append(get_rng_type_to(state, term_rng))\n\n        typecasts = []\n        for i, term_type in enumerate(term_types):\n            other_types = term_types[:i] + term_types[i+1:]\n            typecast = term_type.get_operate_typecast(opr, other_types)\n            if typecast:\n                typecast = state.all_types_to[typecast]\n            typecasts.append((term_type, typecast))\n        return typecasts\n\n    return get_term_str, get_opr_str, get_typecasts\n\n\ndef get_rng_type_to(state, rng):\n    return state.get_eq_type(state.type_solved_rng[rng], state.TYPE)\n\n\ndef solve_capsule(state, opr_capsule, convert, is_root_capsule=False):\n    operator = opr_capsule.opr_str\n\n    get_term_str, get_opr_str, get_typecasts = get_str_wrapper(state, convert)\n\n    iter_indexing = operator == \"[ ]\" and len(opr_capsule.terms) == 2\n\n    if not is_root_capsule:\n        settings = state.conversions.conv_filters.default_settings\n        capsule_start, capsule_end = opr_capsule.start, opr_capsule.end\n        conv = state.conversions.conversions_space.get_conv(\n            opr_capsule.start, settings, capsule_start, capsule_end)\n        if (conv.start, conv.end) == (capsule_start, capsule_end):\n            return convert(capsule_start, capsule_end)\n\n    if len(opr_capsule.terms_rng) != 0:\n        t0_rng = opr_capsule.terms_rng[0]\n        t0_type = get_rng_type_to(state, t0_rng)\n    else:\n        t0_type = None\n        t0_rng = (-1, -1)\n\n    if len(opr_capsule.terms_rng) > 1:\n        t1_rng = opr_capsule.terms_rng[1]\n        t1_type = get_rng_type_to(state, t1_rng)\n    else:\n        t1_type = None\n\n    opr_overload = state.database.get_opr_conv(operator, t0_type, t1_type)\n    if opr_overload:\n        opr = state.words[t0_rng[1]]\n        conv_res = state.execute(\n            opr_overload, {\"opr\": opr, \"opr_capsule\": opr_capsule},\n            func=\"to_str\")\n        if conv_res:\n            return conv_res\n\n    if iter_indexing:\n        iterable, index = opr_capsule.terms\n        return \"{}[{}]\".format(get_term_str(iterable), get_term_str(index))\n\n    if operator == \"**\":\n        state.import_lib((\"Math\", \"java.lang.Math\"))\n        lhs, rhs = opr_capsule.terms\n        return \"Math.pow({},{})\".format(get_term_str(lhs), get_term_str(rhs))\n\n    if operator == \"//\":\n        state.import_lib((\"Math\", \"java.lang.Math\"))\n        lhs, rhs = opr_capsule.terms\n        lhs_rng, rhs_rng = opr_capsule.terms_rng\n\n        lhs_type_to = get_rng_type_to(state, lhs_rng)\n        lhs_str, rhs_str = get_term_str(lhs), get_term_str(rhs)\n        if lhs_type_to == \"double\":\n            return \"Math.floorDiv((long){},{})\".format(lhs_str, rhs_str)\n        return \"Math.floorDiv({},{})\".format(lhs_str, rhs_str)\n\n    if operator == \"/\":\n        lhs, rhs = opr_capsule.terms\n        lhs_rng, rhs_rng = opr_capsule.terms_rng\n        lhs_type_to = get_rng_type_to(state, lhs_rng)\n        rhs_type_to = get_rng_type_to(state, rhs_rng)\n        if lhs_type_to == \"int\" and rhs_type_to == \"int\":\n            return \"(double){}/{}\".format(\n                get_term_str(lhs), get_term_str(rhs))\n\n    if operator == \"()\":\n        return \"({})\".format(get_term_str(opr_capsule.terms[0]))\n    elif operator == \"[ ]\":\n        terms = (get_term_str(opr_capsule.terms[0]) if len(opr_capsule.terms)\n                 else \"\")\n        return \"{\" + terms + \"}\"\n\n    if operator in [\"or\", \"and\"]:\n        lhs, rhs = opr_capsule.terms\n        term_types = [get_rng_type_to(state, term_rng)\n                      for term_rng in opr_capsule.terms_rng]\n        opr_str = get_opr_str(opr_capsule.opr_words[0])\n        terms_str = [get_term_str(lhs), get_term_str(rhs)]\n        for i, term_type in enumerate(term_types):\n            terms_str[i] = term_type.typecast(\n                terms_str[i], state.all_types_to[\"bool\"])\n        return \"{}{}{}\".format(terms_str[0], opr_str, terms_str[1])\n\n    if operator == \"not in\":\n        code = state.words[opr_capsule.start: opr_capsule.end]\n        not_in_opr_index = opr_capsule.opr_words[0].index - opr_capsule.start\n        code.pop(not_in_opr_index)\n        code.insert(not_in_opr_index, \"in\")\n        res = state.convert_snippet(f\"not({' '.join(code)})\",\n                                    opr_capsule.start)\n        return res\n\n    if len(opr_capsule.terms) == 1:\n        opr_str = get_opr_str(opr_capsule.opr_words[0])\n        if opr_str[-1].isalnum():\n            opr_str += \" \"\n        return \"{}{}\".format(opr_str, get_term_str(opr_capsule.terms[0]))\n    elif len(opr_capsule.terms) == 2:\n        lhs, rhs = opr_capsule.terms\n        typecasts = get_typecasts(opr_capsule.terms_rng, operator)\n        opr_str = get_opr_str(opr_capsule.opr_words[0])\n        terms_str = [get_term_str(lhs), get_term_str(rhs)]\n        for i, (term_type, typecast_type) in enumerate(typecasts):\n            if typecast_type is not None:\n                terms_str[i] = term_type.typecast(terms_str[i], typecast_type)\n        return \"{}{}{}\".format(terms_str[0], opr_str, terms_str[1])\n    return convert(opr_capsule.start, opr_capsule.end)\n",
    "priority": 1
  },
  "-/to/Coll-Bridge/python/Coll-Bridge/misc/return": {
    "code": "def match(words, index, str_funcs, state, **kwargs):\n    if words[index] == \"return\":\n        end = words[index].tags[\"stmt\"].end\n        return index, range(index, end), {\"start\": index+1, \"end\": end}\n\n\ndef to_str(start, end, convert, state, **kwargs):\n\n    ret_val_str = str(convert(start, end))\n    ret_str = \"return\"\n    upper_type = state.get_upper(start).get_type_to()\n    if (start, end) in state.type_solved_rng:\n        ret_val_type = state.get_eq_type(\n            state.type_solved_rng[(start, end)], state.TYPE)\n        ret_val_str = ret_val_type.typecast(ret_val_str, upper_type)\n    if ret_val_str:\n        ret_str += \" \" + ret_val_str\n    elif upper_type != state.all_types_to[\"None\"]:\n        ret_str = \"return null\"\n    return ret_str\n",
    "priority": 1
  },
  "-/to/Coll-Bridge/python/Coll-Bridge/misc/symbols": {
    "code": "def match(words, index, **kwargs):\n    word_type = words[index].tok_type\n    if word_type.endswith(\"symbol\") or word_type.endswith(\"_op\"):\n        return index, range(index, index+1), {\"symbol\": words[index]}\n\n\ndef to_str(symbol, **kwargs):\n    return str(symbol)\n",
    "priority": 1
  },
  "-/to/Coll-Bridge/python/Coll-Bridge/misc/while": {
    "code": "def match(words, index, str_funcs, state, **kwargs):\n    if words[index] == \"while\":\n        end = words[index].tags[\"stmt\"].end\n        if words[end-1] == \":\":\n            end += 1\n            return index, range(index, end), {\"start\": index, \"end\": end}\n\n\ndef to_str(start, end, convert, **kwargs):\n    cond = str(convert(start+1, end-2))\n    if not cond or cond[0] != \"(\" or cond[-1] != \")\":\n        cond = f\"({cond})\"\n    return f\"while{cond}\"\n",
    "priority": 1
  },
  "-/to/Coll-Bridge/python/Coll-Bridge/obj_mod/global_objs": {
    "code": "def match(obj_usage, **kwargs):\n\n    if obj_usage and obj_usage.obj.get_upper() is None:\n        start = (obj_usage.start if hasattr(obj_usage, \"start\") else\n                 obj_usage.index)\n        return start, range(start, obj_usage.end), {\"obj_usage\": obj_usage}\n\n\ndef modify(obj_usage, **kwargs):\n    obj_usage.obj.scope = \"static\"\n",
    "priority": 1
  },
  "-/to/Coll-Bridge/python/Coll-Bridge/obj_mod/ret_check": {
    "code": "def match(obj_usage, state, **kwargs):\n\n    if not obj_usage.obj.is_func or obj_usage.usage_type != \"def\":\n        return\n\n    func = obj_usage.obj\n    func_stmt = state.words[func.index].tags[\"stmt\"]\n    path_rets = []\n    if not hasattr(func_stmt, \"paths\"):\n        return\n\n    for path in func_stmt.paths:\n        path_rets.append(\n            any(node.stmt.stmt_type == \"return\"\n                for node in path.iterate(same_lvl=True, all_=False)))\n\n    any_returns = any(path_rets)\n    base_ret = path_rets.pop(0)\n    all_path_rets = path_rets and all(path_rets)\n\n    # has_ret_not_all_paths = (not(base_ret or all(path_rets)) and any_returns)\n    # has_type_no_rets = (not any_returns and func.get_type_from() != \"None\")\n    # if has_ret_not_all_paths or has_type_no_rets:\n\n    has_type_not_all_paths = (func.get_type_from() != \"None\" and\n                              not(base_ret or all_path_rets))\n    if has_type_not_all_paths:\n        start = obj_usage.start\n        return start, range(start, obj_usage.end), {\"func\": func}\n\n\ndef modify(func, state, **kwargs):\n\n    func_upper = func.get_upper()\n    if func_upper and func_upper.is_struct and func.abs_name == \"__init__\":\n        return\n    func.values.append(state.all_types_from[\"None\"])\n    state.add_line_before(func.body_end - 1, \"return null;\")\n",
    "priority": 1
  },
  "-/to/Coll-Bridge/python/Coll-Bridge/obj_mod/static_attr_extend": {
    "code": "def match(obj_usage, state, **kwargs):\n\n    if obj_usage.usage_type != \"set\":\n        return\n\n    call_path = obj_usage.call_path\n    if len(call_path) > 1 and call_path[-2].is_instance:\n        upper = call_path[-2]\n        struct = state.get_struct(upper)\n        if (obj_usage.var.abs_name not in struct.attrs\n                or obj_usage.var != struct.attrs[obj_usage.var.abs_name]):\n            return\n\n        struct_attr = struct.attrs[obj_usage.var.abs_name]\n        if len(struct_attr.linked_objs) > 1:\n            return\n\n        params = {\"obj_usage\": obj_usage, \"struct_attr\": struct_attr}\n        return obj_usage.start, range(obj_usage.start, obj_usage.end), params\n\n\ndef modify(obj_usage, struct_attr, state, **kwargs):\n    state.obj_map.re_ref_loc(struct_attr, obj_usage.var.linked_objs)\n",
    "priority": 1
  },
  "-/to/Coll-Bridge/python/Coll-Bridge/obj_mod/str_format": {
    "code": "def match(obj_usage, **kwargs):\n    if (obj_usage and obj_usage.obj.abs_name == \"format\"\n            and obj_usage.call_path[-2].type_from == \"str\"):\n        start = obj_usage.start\n        return start, range(start, obj_usage.end), {\"obj_usage\": obj_usage}\n\n\ndef modify(state, obj_usage, **kwargs):\n    values = []\n    format_calls = []\n    if obj_usage.call_path[-2].is_const:\n        values = [obj_usage.call_path[-2].const_word]\n        format_calls = [obj_usage]\n    else:\n        for linked_obj in obj_usage.call_path[-2].linked_objs:\n            values.append(linked_obj.value[0])\n\n            for usage in linked_obj.usages[\"mid_man\"].values():\n                if (usage.usage_type == \"call\"\n                        and usage.obj.abs_name == \"format\"):\n                    format_calls.append(usage)\n\n    format_arg_sets = [format_call.args for format_call in format_calls]\n    arg_types = []\n    for format_args in format_arg_sets:\n        for i, arg in enumerate(format_args.values()):\n            state.solve_type(arg)\n            if len(arg_types) > i:\n                arg_types[i] += arg.type_\n            else:\n                arg_types.append(arg.type_)\n\n    for value in values:\n        format_locs = []\n        format_char_start = -1\n        mod_value = org_value = value\n        len_value = len(org_value)\n        for i, char in enumerate(org_value):\n            next_char = org_value[i+1] if i+1 != len_value else \"\"\n            if char == \"{\" and next_char != \"{\":\n                format_char_start = i\n            if char == \"}\" and next_char != \"}\":\n                format_locs.append((format_char_start, i))\n            i += 1\n        loc_types = zip(format_locs, arg_types)\n        for loc, type_ in loc_types:\n            format_code = \"%s\"\n            if type_ == \"Integer\" or type_ == \"int\":\n                format_code = \"%d\"\n            elif type_ in [\"Float\", \"float\", \"Double\", \"double\"]:\n                format_code = \"%f\"\n            elif type_ == \"Char\" or type_ == \"char\":\n                format_code = \"%c\"\n            mod_value = mod_value[:loc[0]] + format_code + mod_value[loc[1]+1:]\n        state.str_funcs.change_word(org_value, mod_value)\n"
  },
  "-/to/Coll-Bridge/python/Coll-Bridge/obj_mod/this_prefix_cls": {
    "code": "def match(obj_usage, **kwargs):\n    if (obj_usage and len(obj_usage.call_path) > 1\n            and obj_usage.call_path[1].is_struct\n            and not obj_usage.call_path[0].is_struct):\n        start = obj_usage.start\n        return start, range(start, obj_usage.end), {\"obj_usage\": obj_usage}\n\n\ndef modify(obj_usage, **kwargs):\n    obj_usage.call_path = obj_usage.call_path.copy(1)\n",
    "priority": 1
  },
  "-/to/Coll-Bridge/python/Coll-Bridge/operator_overloads/Coll-Bridge/->Map<String,Map<String,String>>/in": {
    "code": "def to_str(state, opr_capsule, convert, **kwargs):\n    lhs_rng, rhs_rng = opr_capsule.terms_rng\n    lhs = convert(*lhs_rng)\n    rhs = convert(*rhs_rng)\n    return f\"{rhs}.keySet().contains({lhs})\"\n"
  },
  "-/to/Coll-Bridge/python/Coll-Bridge/operator_overloads/Coll-Bridge/->Map<String,String>/in": {
    "code": "def to_str(state, opr_capsule, convert, **kwargs):\n    lhs_rng, rhs_rng = opr_capsule.terms_rng\n    lhs = convert(*lhs_rng)\n    rhs = convert(*rhs_rng)\n    return f\"{rhs}.keySet().contains({lhs})\"\n"
  },
  "-/to/Coll-Bridge/python/Coll-Bridge/operator_overloads/Coll-Bridge/ArrayList<Integer>/[ ]": {
    "code": "def to_str(opr, convert, solve_type, **kwargs):\n    lhs = convert(opr.tags[\"lhs\"].start, opr.tags[\"lhs\"].end)\n    rhs = convert(opr.tags[\"pair_value\"].start, opr.tags[\"pair_value\"].end)\n    for operand in [\"lhs\", \"pair_value\"]:\n        if isinstance(opr.tags[operand].type_, list):\n            solve_type(opr.tags[operand])\n    if opr.tags[\"pair_value\"].type_.base_eq == \"int\":\n        return f\"{lhs}.get({rhs})\"\n    return \"\"\n"
  },
  "-/to/Coll-Bridge/python/Coll-Bridge/operator_overloads/Coll-Bridge/ArrayList<Integer[]>/[ ]": {
    "code": "def to_str(opr, convert, solve_type, **kwargs):\n    lhs = convert(opr.tags[\"lhs\"].start, opr.tags[\"lhs\"].end)\n    rhs = convert(opr.tags[\"pair_value\"].start, opr.tags[\"pair_value\"].end)\n    if opr.tags[\"pair_value\"].type_.base_eq == \"int\":\n        return f\"{lhs}.get({rhs})\"\n    return \"\"\n"
  },
  "-/to/Coll-Bridge/python/Coll-Bridge/operator_overloads/Coll-Bridge/ArrayList<String>/+": {
    "code": "def to_str(opr_capsule, convert, state, **kwargs):\n    lhs_rng, rhs_rng = opr_capsule.terms_rng\n    lhs = convert(*lhs_rng)\n    rhs = convert(*rhs_rng)\n    res_name = state.get_new_obj_name(lhs_rng[0], [\"listSumRes\"], \"listSumRes\")\n    stmt_start = state.words[lhs_rng[0]].tags[\"stmt\"]\n    state.add_line_before(stmt_start, f\"{res_name}.addAll({lhs})\")\n    state.add_line_before(stmt_start, f\"{res_name}.addAll({rhs})\")\n    return res_name\n"
  },
  "-/to/Coll-Bridge/python/Coll-Bridge/operator_overloads/Coll-Bridge/Map-Entry<String,Map<String,String>>/[ ]": {
    "code": "def to_str(opr, convert, solve_type, **kwargs):\n    lhs = convert(opr.tags[\"lhs\"].start, opr.tags[\"lhs\"].end)\n    rhs = convert(opr.tags[\"pair_value\"].start, opr.tags[\"pair_value\"].end)\n    if opr.tags[\"pair_value\"] == [\"0\"]:\n        return f\"{lhs}.getKey()\"\n    elif opr.tags[\"pair_value\"] == [\"1\"]:\n        return f\"{lhs}.getValue()\"\n    for operand in [\"lhs\", \"pair_value\"]:\n        if isinstance(opr.tags[operand].type_, list):\n            solve_type(opr.tags[operand])\n    if opr.tags[\"pair_value\"].type_.base_eq == \"int\":\n        return f\"{lhs}.get({rhs})\"\n    return \"\"\n"
  },
  "-/to/Coll-Bridge/python/Coll-Bridge/operator_overloads/Coll-Bridge/Map-Entry<String,String>/[ ]": {
    "code": "def to_str(opr, convert, solve_type, **kwargs):\n    lhs = convert(opr.tags[\"lhs\"].start, opr.tags[\"lhs\"].end)\n    rhs = convert(opr.tags[\"pair_value\"].start, opr.tags[\"pair_value\"].end)\n    if opr.tags[\"pair_value\"] == [\"0\"]:\n        return f\"{lhs}.getKey()\"\n    elif opr.tags[\"pair_value\"] == [\"1\"]:\n        return f\"{lhs}.getValue()\"\n    for operand in [\"lhs\", \"pair_value\"]:\n        if isinstance(opr.tags[operand].type_, list):\n            solve_type(opr.tags[operand])\n    if opr.tags[\"pair_value\"].type_.base_eq == \"int\":\n        return f\"{lhs}.get({rhs})\"\n    return \"\"\n"
  },
  "-/to/Coll-Bridge/python/Coll-Bridge/operator_overloads/Coll-Bridge/Map<String,String>/[ ]": {
    "code": "def to_str(state, opr_capsule, convert, **kwargs):\n    lhs_rng, rhs_rng = opr_capsule.terms_rng\n    lhs = convert(*lhs_rng)\n    rhs = convert(*rhs_rng)\n    return f\"{lhs}.get({rhs})\"\n"
  },
  "-/to/Coll-Bridge/python/Coll-Bridge/operator_overloads/Coll-Bridge/Object[]/+": {
    "code": "def to_str(opr_capsule, convert, state, **kwargs):\n    lhs_rng, rhs_rng = opr_capsule.terms_rng\n    lhs = convert(*lhs_rng)\n    rhs = convert(*rhs_rng)\n    res_name = state.get_new_obj_name(lhs_rng[0], [\"listSumRes\"], \"listSumRes\")\n    stmt_start = state.words[lhs_rng[0]].tags[\"stmt\"].start\n    state.add_line_before(stmt_start, f\"{res_name}.addAll({lhs});\")\n    state.add_line_before(stmt_start, f\"{res_name}.addAll({rhs});\")\n    return res_name\n"
  },
  "-/to/Coll-Bridge/python/Coll-Bridge/operator_overloads/Coll-Bridge/String/!=": {
    "code": "def to_str(state, opr, opr_capsule, convert, **kwargs):\n    lhs_rng, rhs_rng = opr_capsule.terms_rng\n    rhs_type = state.get_eq_type(state.type_solved_rng[rhs_rng], state.TYPE)\n    lhs = convert(lhs_rng[0], lhs_rng[1])\n    rhs = convert(rhs_rng[0], rhs_rng[1])\n    if rhs_type in [\"int\", \"Integer\", \"float\", \"Float\", \"double\", \"Double\"]:\n        rhs = f\"String.valueOf({rhs})\"\n    lhs = f\"({lhs})\" if lhs_rng[1]-lhs_rng[0] > 1 else lhs\n    return f\"!{lhs}.equals({rhs})\"\n"
  },
  "-/to/Coll-Bridge/python/Coll-Bridge/operator_overloads/Coll-Bridge/String/%": {
    "code": "def to_str(state, opr_capsule, convert, **kwargs):\n    lhs_rng, rhs_rng = opr_capsule.terms_rng\n    lhs = convert(*lhs_rng)\n    rhs = convert(*rhs_rng)\n\n    return f\"String.format({lhs}, {rhs})\"\n"
  },
  "-/to/Coll-Bridge/python/Coll-Bridge/operator_overloads/Coll-Bridge/String/*": {
    "code": "def to_str(state, opr_capsule, convert, **kwargs):\n    lhs_rng, rhs_rng = opr_capsule.terms_rng\n    lhs = convert(*lhs_rng)\n    rhs = convert(*rhs_rng)\n\n    return f\"{lhs}.repeat({rhs})\"\n"
  },
  "-/to/Coll-Bridge/python/Coll-Bridge/operator_overloads/Coll-Bridge/String/==": {
    "code": "def to_str(state, opr, opr_capsule, convert, **kwargs):\n    lhs_rng, rhs_rng = opr_capsule.terms_rng\n    rhs_type = state.get_eq_type(state.type_solved_rng[rhs_rng], state.TYPE)\n    lhs = convert(lhs_rng[0], lhs_rng[1])\n    rhs = convert(rhs_rng[0], rhs_rng[1])\n    if rhs_type in [\"int\", \"Integer\", \"float\", \"Float\", \"double\", \"Double\"]:\n        rhs = f\"String.valueOf({rhs})\"\n    return f\"{lhs}.equals({rhs})\"\n"
  },
  "-/to/Coll-Bridge/python/Coll-Bridge/operator_overloads/Coll-Bridge/String/[ ]": {
    "code": "def to_str(state, opr_capsule, convert, **kwargs):\n    lhs_rng, rhs_rng = opr_capsule.terms_rng\n    lhs = convert(*lhs_rng)\n    rhs = convert(*rhs_rng)\n\n    if state.get_eq_type(state.type_solved_rng[rhs_rng], state.TYPE) == \"int\":\n        return f\"{lhs}.charAt({rhs})\"\n"
  },
  "-/to/Coll-Bridge/python/Coll-Bridge/operator_overloads/Coll-Bridge/String/in": {
    "code": "def to_str(state, opr, convert, **kwargs):\n    state.import_lib((\"Arrays\", \"java.util.Arrays\"))\n    lhs = convert(opr.tags[\"lhs\"].start, opr.tags[\"lhs\"].end)\n    rhs = convert(opr.tags[\"rhs\"].start, opr.tags[\"rhs\"].end)\n    return f\"Arrays.asList({rhs}).contains({lhs})\"\n"
  },
  "-/to/Coll-Bridge/python/Coll-Bridge/operator_overloads/Coll-Bridge/char/*": {
    "code": "def to_str(state, opr_capsule, convert, **kwargs):\n    lhs_rng, rhs_rng = opr_capsule.terms_rng\n    lhs = convert(*lhs_rng)\n    rhs = convert(*rhs_rng)\n\n    return f\"String.valueOf({lhs}).repeat({rhs})\"\n"
  },
  "-/to/Coll-Bridge/python/Coll-Bridge/operator_overloads/Coll-Bridge/char/==": {
    "code": "def to_str(state, opr, opr_capsule, convert, **kwargs):\n    lhs_rng, rhs_rng = opr_capsule.terms_rng\n    rhs_type = state.get_eq_type(state.type_solved_rng[rhs_rng], state.TYPE)\n    lhs = convert(lhs_rng[0], lhs_rng[1])\n    rhs = convert(rhs_rng[0], rhs_rng[1])\n    if rhs_type not in [\"String\", \"char\", \"Character\"]:\n        return \"false\"\n\n    if rhs_type == \"String\":\n        rhs_value = state.words[opr.index].tags[\"rhs\"]\n        rhs_word = state.words[rhs_value[0].index]\n        if (\"const\" in rhs_word.tags and rhs_word.tags[\"const\"] == \"str\"\n                and len(rhs_value) == 1 and len(rhs_value[0]) == 3):\n            rhs = f\"'{rhs[1]}'\"\n        else:\n            return f\"Character.toString({lhs}).equals({rhs})\"\n    return f\"{lhs}=={rhs}\"\n"
  },
  "-/to/Coll-Bridge/python/Coll-Bridge/operator_overloads/Coll-Bridge/int/in": {
    "code": "def to_str(state, opr, opr_capsule, convert, **kwargs):\n    state.import_lib((\"Arrays\", \"java.util.Arrays\"))\n    lhs_rng, rhs_rng = opr_capsule.terms_rng\n    lhs, rhs = convert(*lhs_rng), convert(*rhs_rng)\n    rhs_type = state.get_eq_type(state.type_solved_rng[rhs_rng], state.TYPE)\n    if rhs_type == \"int[]\":\n        i_name = state.get_new_obj_name(opr.index)\n        return f\"Arrays.stream({rhs}).anyMatch({i_name} -> {i_name} == {lhs})\"\n    return f\"Arrays.asList({rhs}).contains({lhs})\"\n",
    "priority": 2
  },
  "-/to/Coll-Bridge/python/Coll-Bridge/reserved/add_nglot_funcs": {
    "code": "def add_funcs(state, **kwargs):\n\n    if not state.nglot_funcs:\n        return\n\n    code = \"class {} {{\".format(state.helper_class_name)\n\n    for func_name, func_code in state.nglot_funcs.items():\n        code += func_code\n\n    state.paste_bottom(code + \"}\")\n",
    "priority": 1
  },
  "-/to/Coll-Bridge/python/Coll-Bridge/reserved/boilerplate": {
    "code": "def template(state, **kwargs):\n\n    if state.converting_snippet:\n        return \"@@main@@\"\n\n    boilerplate = \"@@imports@@\"\n    if state.conversions.core_comps[\"main\"]:\n        boilerplate += (\n            \"public class @@filename@@{@@global_vars@@\"\n            + \"public static void main(String[]args){\"\n            + \"@@main@@}@@global_funcs@@}\"\n        )\n    elif state.conversions.core_comps[\"global_funcs\"]:\n        boilerplate += \"public class @@filename@@{@@global_funcs@@}\"\n\n    boilerplate += \"@@global_structs@@\"\n    return boilerplate\n",
    "priority": 1
  },
  "-/to/Coll-Bridge/python/Coll-Bridge/reserved/check_attrs": {
    "code": "def is_coll(type_):\n    return str(type_).endswith(\"[]\")\n\n\ndef is_pointer(var):\n    return var.is_collection\n",
    "priority": 1
  },
  "-/to/Coll-Bridge/python/Coll-Bridge/reserved/func_convert": {
    "code": "def def_parse(state, func_usage, func, prefix, conv_func):\n    convert = state.conversions.convert\n    func = func_usage.func\n    func_upper = func.get_upper()\n    if (func_upper and func_upper.is_struct\n            and func_usage.modifier != \"static\"):\n        func.args[0].rename(\"this\")\n\n    ret_type = func.get_type_to()\n    if not ret_type or str(ret_type) == \"null\":\n        ret_type = state.all_types_to[\"void\"]\n    args_str = \"\"\n\n    for arg_name in func.pos_args:\n        arg = func.args[arg_name]\n        arg_type = (arg.type_ if str(arg.type_) != \"null\" else\n                    state.all_types_to[\"Object\"])\n\n        args_str += \"{} {},\".format(arg_type, arg_name)\n\n    # ASSUMPTION: function name must be a single name in the language,\n    # hence \"name\" is valid while \"name.attr\" as a function name is\n    # assumed to be invalid in all possible languages\n    func_name = func.abs_name\n    converted = False\n    is_constructor = False\n    if func_upper:\n        if func_name == \"__init__\":\n            conv_func += \"{}\".format(func_upper.abs_name)\n            is_constructor = True\n            converted = True\n        elif not func_upper or not func_upper.is_struct:\n            prefix = \"class \" + func_name + \"{\"\n            func_name = \"run\"\n\n            for call_usage in func.usages[\"call\"].values():\n                call_usage.call_path = \"new {}().run\".format(\n                    call_usage.call_path)\n            state.add_line_before(func.body_end, \"}\")\n\n    if not converted:\n        conv_func += \"{} {}\".format(ret_type, func_name)\n\n    if func_usage.kw_args:\n        func.find_prototypes()\n        if len(func.prototypes) > 10:\n\n            # TODO: Builder class\n            raise NotImplementedError(\"Builder Class\")\n        else:\n\n            # ASSUMPTION: argument name must be a single name in the\n            # language, hence \"name\" is valid while \"name.attr\" as an\n            # argument name is assumed to be invalid in all possible\n            # languages\n            main_args = {arg: None for arg in func.pos_args}\n            for arg_name in func.kw_args:\n                arg = func.args[arg_name]\n                converted_val = convert(arg.value.start, arg.value.end)\n                args_str += \"{} {},\".format(arg.type_, arg.abs_name,\n                                            converted_val)\n\n                main_args[arg.abs_name] = converted_val\n\n            for args in func.prototypes:\n                args_obj = [func.args[arg_name] for arg_type, arg_name in args]\n                arg_names = {arg.abs_name for arg in args_obj}\n\n                format_str = conv_func + \"({args})\"\n                overload_args_str = \",\".join(\n                    \"{} {}\".format(arg[0], arg[1]) for arg in args)\n\n                func_sign = format_str.format(f=func_usage,\n                                              args=overload_args_str,\n                                              ret_type=ret_type).strip()\n\n                call_arg_str = \"\".join(str(arg.abs_name) + \",\" for arg in\n                                       args_obj)\n                for arg in main_args:\n                    if arg not in arg_names:\n                        call_arg_str += str(main_args[arg]) + \",\"\n                call_arg_str = call_arg_str[:-1]\n\n                call_func = \"this\" if is_constructor else func_name\n                state.add_line_before(func.body_end,\n                                      func_sign + \"{\" + call_func + \"(\"\n                                      + call_arg_str + \");}\")\n\n    if args_str:\n        args_str = args_str[:-1]\n\n    conv_func += \"({})\".format(args_str)\n    return prefix, conv_func\n\n\ndef call_parse(state, func_usage, func, prefix, conv_func):\n    convert = state.conversions.convert\n    conv_dat = state.conversions.get_conv_dat\n\n    if func_usage.has_lib_conv:\n\n        call_conv = state.conversions.run_lib_conv(func_usage)\n        if isinstance(call_conv, str):\n            return \"\", call_conv\n    else:\n        call_conv = conv_dat(func_usage.start, func_usage.end,\n                             settings=\"func_call_conv\")\n    if call_conv and len(call_conv) == 3:\n        name, args, libs = call_conv\n    else:\n        name, args = str(func_usage.call_path), func_usage.args.values()\n\n        if func.lib_path and func.lib_path != \"in+code\":\n            libs = [(func.lib_path,)]\n        else:\n            libs = []\n    for lib in libs:\n        state.import_lib(lib)\n    args_str = \"\"\n    for arg in args:\n        if hasattr(arg, \"start\") and arg.start != -1:\n            converted_val = \"\"\n            if arg.type_ != arg.type_from and hasattr(arg, \"is_var\"):\n                converted_val = f\"({arg.type_from})\"\n            converted_val += str(convert(arg.start, arg.end))\n        else:\n            converted_val = str(arg)\n        args_str += str(converted_val) + \",\"\n\n    if isinstance(call_conv, str):\n        name = call_conv\n\n    conv_func += \"{}({})\".format(name, args_str[:-1])\n    return prefix, conv_func\n\n\ndef parse_func_usage(state, func_usage):\n    func = func_usage.func\n\n    prefix = \"\"\n    conv_func = \"\"\n\n    if func.scope and func_usage.usage_type == \"def\":\n        conv_func = func.scope + \" \"\n    if func_usage.modifier:\n        conv_func += func_usage.modifier + \" \"\n\n    if func_usage.usage_type == \"def\":\n        prefix, conv_func = def_parse(state, func_usage, func,\n                                      prefix, conv_func)\n    else:\n        prefix, conv_func = call_parse(state, func_usage, func,\n                                       prefix, conv_func)\n\n    return prefix + conv_func\n\n\ndef to_str(func_stmt, state, **kwargs):\n    return \";\".join([parse_func_usage(state, func_usage)\n                     for func_usage in func_stmt.func_usages])\n\n\ndef match(words, index, **kwargs):\n    func_stmt = words[index].tags[\"func_stmt\"]\n    return (func_stmt.start, range(func_stmt.start, func_stmt.end),\n            {\"func_stmt\": func_stmt})\n",
    "priority": 1
  },
  "-/to/Coll-Bridge/python/Coll-Bridge/reserved/get_coll_type": {
    "code": "def main(state, type_sets, from_coll_type, **kwargs):\n    list_comp = kwargs[\"list_comp\"] if \"list_comp\" in kwargs else False\n    if from_coll_type == \"list\":\n        type_set = type_sets[0]\n        if type_set:\n            list_type = sum(type_set, start=next(iter(type_set)))\n            if list_comp:\n                list_type += state.all_types_to[\"null\"]\n                type_ = state.all_types_to[f\"List<{list_type}>\"].copy(True)\n            else:\n                type_ = state.all_types_to[str(list_type) + \"[]\"].copy(True)\n            type_.info[\"type_set\"] = type_set\n        else:\n            type_ = state.all_types_to[\"None\"]\n        return type_\n    else:\n        types = []\n        for type_set in type_sets:\n            if type_set:\n                list_type = sum(type_set, start=next(iter(type_set)))\n                type_ = state.all_types_to[str(list_type)].copy(True)\n            else:\n                type_ = state.all_types_to[\"Object\"]\n            types.append(type_)\n        type_ = state.all_types_to[f\"Map<{types[0]},{types[1]}>\"]\n        type_.info[\"type_sets\"] = type_sets\n        type_.info[\"types\"] = types\n        return type_\n\n"
  },
  "-/to/Coll-Bridge/python/Coll-Bridge/reserved/import_lib": {
    "code": "def to_str(lib, **kwargs):\n    if isinstance(lib, tuple):\n        if len(lib) == 1:\n            return \"import {};\".format(lib[0])\n        return \"import {1};\".format(*lib)\n    raise ValueError(\"Invalid Lib Argument: {}\".format(lib))\n",
    "priority": 1
  },
  "-/to/Coll-Bridge/python/Coll-Bridge/reserved/main_stmts": {
    "code": "def extract(state, str_funcs, words, **kwargs):\n\n    main_body = []\n    global_words = state.global_stmts[\"all\"]\n\n    entry_caller_p1 = [\"if\", \"__name__\", \"==\", '\"__main__\"', \":\", \"\\n\",\n                       \"INDENT\"]\n    main_caller = [\"main\", \"(\", \")\"]\n    entry_caller_p2 = main_caller + [\"\\n\", \"DEDENT\"]\n\n    # Find if statement\n    if_stmt = str_funcs.find_seg(global_words, entry_caller_p1)\n    if_stmt_indexes = list(range(if_stmt, if_stmt+len(entry_caller_p1)))\n\n    # Find main call after if statement\n    main_call = str_funcs.find_seg(global_words, entry_caller_p2, if_stmt)\n\n    # Confirm last line of file to be main call\n    last_words = []\n    word_count = len(state.words) - 2\n    len_entry_caller_p2 = len(entry_caller_p2)\n    for i in state.words.iterate_range(0, len_entry_caller_p2):\n        try:\n            last_words.append(global_words[word_count-len_entry_caller_p2+i+1])\n        except KeyError:\n            last_words = None\n            break\n    main_call_end = last_words == entry_caller_p2\n\n    # Check if main function return type is None and if main has any arguments\n    func_def = no_args = none_ret_type = False\n    if main_call_end:\n        func_def = state.find_in_scope(\"main\", main_call + 1)\n        main_def_type = func_def.get_type_from()\n        none_ret_type = main_def_type == \"None\"\n        no_args = not func_def.args\n        if_stmt_indexes += [main_call+len(entry_caller_p2)-1]\n\n    if if_stmt != -1 and main_call_end and none_ret_type and no_args:\n        skip_till = -1\n        for i, word in state.global_stmts[\"all_mod\"].items():\n            if skip_till != -1:\n                if i < skip_till:\n                    continue\n                skip_till = -1\n            if i in if_stmt_indexes:\n                continue\n            if word.__class__.__name__ == \"FunctionUsage\":\n                if word.usage_type == \"call\":\n                    if word.func.ref_loc == \"main\" and func_def:\n                        def_usage = next(iter(func_def.usages[\"def\"].values()))\n                        main_body.append((def_usage.end + 1,\n                                          func_def.body_end - 2))\n                        state.global_stmts[\"func_defs\"].remove(def_usage)\n                    else:\n                        main_body.extend(list(range(word.start, word.end)))\n\n            elif word.__class__.__name__ == \"VariableUsage\":\n                if word.usage_type != \"struct\":\n                    main_body.extend(list(range(word.start, word.end)))\n            else:\n                main_body.append(i)\n    else:\n        # If there is any main function rename it to pyMain\n        py_main = state.find_in_scope(\"main\", throw_error=False)\n        if py_main:\n            py_main.rename(\"pyMain\")\n\n        skip_till = None\n        for i, stmt in state.global_stmts[\"all_mod\"].items():\n            if skip_till is not None:\n                if i < skip_till:\n                    continue\n                skip_till = None\n            if (hasattr(stmt, \"usage_type\")\n                    and stmt.usage_type in [\"def\", \"struct\"]):\n                continue\n            if stmt == \"if\" and len(words) >= i + 6:\n                if words[i:i+5] == [\"if\", \"__name__\", \"==\", '\"__main__\"', \":\"]:\n                    prefix, blk, skip_till = str_funcs.get_block(i+4)\n                    start = i+4+len(prefix)\n                    main_body += range(start, start + len(blk) - 1)\n                    continue\n            if hasattr(stmt, \"start\"):\n                main_body += list(range(stmt.start, stmt.end))\n            else:\n                main_body.append(i)\n    return main_body\n",
    "priority": 1
  },
  "-/to/Coll-Bridge/python/Coll-Bridge/reserved/var_convert": {
    "code": "def var_get(var_usage, var, state, **kwargs):\n    conv_res = var.type_.to_str(\n        var_usage, str(var_usage.call_path), raise_error=False)\n    if conv_res is None:\n        conv_res = str(var_usage.call_path)\n\n    if (var.type_.base_eq is not None and var.type_from.base_eq is not None\n            and var.type_.base_eq != var.type_from.base_eq):\n\n        # TODO: Replace with type to eq getter\n        to_type = state.all_types_to[var.type_from.base_eq]\n        casted_value = var.type_.typecast(conv_res, to_type)\n        to_str_cnv = to_type.to_str(var_usage, casted_value, raise_error=False)\n        if to_str_cnv is not None:\n            return to_str_cnv\n        return casted_value\n    return conv_res\n\n\ndef var_set(var_usage, var, state, convert, **kwargs):\n\n    modifier, scope, name = var.modifier, var.scope, var_usage.call_path\n\n    do_dec = False\n    if (next(iter(var.linked_objs)) == var and var.abs_name[-1] != \"[\"\n            and not var.is_declared):\n        do_dec = True\n    if \"convert_val\" not in var_usage.info:\n        var_usage.info[\"convert_val\"] = True\n    var_upper = var.get_upper()\n\n    if do_dec and var_upper is not None and var_upper.is_instance:\n        struct_upper = state.get_struct(var_upper)\n        if var.abs_name in struct_upper.attrs:\n            do_dec = False\n        elif var.abs_name in struct_upper.self_obj.attrs:\n            self_obj_attr = struct_upper.self_obj.attrs[var.abs_name]\n            if self_obj_attr.is_declared:\n                do_dec = False\n            else:\n                self_obj_attr.is_declared = True\n\n    dec_prefix = f\"{modifier} {scope} {var.type_}\".strip() if do_dec else \"\"\n\n    if do_dec:\n        dec_stmt = f\"{dec_prefix} {var.abs_name};\".strip()\n        up_struct = state.get_upper(var.index, map_type=\"str\")\n        if isinstance(up_struct, str) and len(up_struct.split()) == 2:\n            dec_end = state.upper_map_str[\"end\"][up_struct]\n            for obj in var.linked_objs:\n                if (next(iter(obj.usages[\"set\"])).index > dec_end or\n                        any(usage.index > dec_end\n                            for usage in obj.usages[\"get\"])):\n                    var.is_global = False\n\n                    # TODO: FIX UPPER MAP STR\n                    loc = state.words.new_index(int(up_struct.split()[0]))\n                    state.add_line_before(loc, dec_stmt)\n                    dec_prefix = \"\"\n                    break\n        if var.is_global:\n            dec_prefix = \"\"\n            state.conversions.pathways[\"global_vars\"].append(dec_stmt)\n        elif len(var_usage.call_path) > 1 and \"attr\" not in kwargs:\n            dec_prefix = \"\"\n            struct = state.get_struct(var_upper)\n            if struct:\n                if scope == \"static\":\n                    state.add_line_before(struct.start, dec_stmt)\n                else:\n                    state.add_line_after(struct.end, dec_stmt)\n\n    if \"attr\" in kwargs:\n        attr = kwargs[\"attr\"]\n        static_name = f\"s_{attr.abs_name}\"\n        static_val = convert(attr.value.start, attr.value.end)\n\n        non_static_dec = f\"{attr.type_} {attr.abs_name}={static_name};\"\n\n        static_dec = f\"static {attr.type_} {static_name}={static_val};\"\n        state.add_line_before(attr.start, static_dec)\n        state.add_line_before(attr.end-1, non_static_dec)\n\n        for instance in var_upper.instances:\n            if attr.abs_name in instance.attrs:\n                instance.attrs[attr.abs_name].is_declared = True\n        var.rename(static_name)\n        dec_prefix = \"\"\n\n    var_stmt = state.words[var.index].tags[\"stmt\"]\n    var_ref_loc = var.ref_loc\n\n    var_sets = state.words[var_stmt.start].tags[\"var_stmt\"].var_usages\n    skip = True\n    for var_set_usage in var_sets:\n        if skip:\n            if var_set_usage == var_usage:\n                skip = False\n            continue\n\n        set_usage_val = var_set_usage.var.value.duplicate()\n        for i, word in enumerate(var_set_usage.var.value):\n            if \"var_usage\" not in word.tags:\n                continue\n            usage_ref_loc = word.tags[\"var_usage\"].var.ref_loc\n            last_part = usage_ref_loc[-1].abs_name\n            usage_ref_loc = str(usage_ref_loc)\n            val = word.tags[\"value\"]\n            k = 1\n            while k < len(val):\n                if val[k] == \"[\":\n                    last_part = f\"{last_part}[\"\n                    usage_ref_loc += \".\" + last_part\n                    k += val[k].tags[\"pair\"] - val[k].index\n\n                k += 1\n\n            if var_ref_loc != usage_ref_loc:\n                continue\n            var_type = var_usage.var.type_\n            state.add_line_before(var_stmt.start,\n                                  f\"{var_type} temp={var_usage.call_path};\")\n            j = var_set_usage.var.value.start + i\n            if \"pair\" in state.words[j+1].tags:\n                replace_end = state.words[j+1].tags[\"pair\"]\n                set_usage_val[i:replace_end+1] = [\"temp\"]\n            else:\n                set_usage_val[i] = \"temp\"\n            var_set_usage.info[\"convert_val\"] = False\n\n        var_set_usage.var.value = set_usage_val\n\n    value = None\n    if state.func_in_module(var.type_.module_code, \"to_str\"):\n        value = state.execute(\n            var.type_.module_code,\n            {\"value\": var.value, \"dec_prefix\": dec_prefix, \"state\": state,\n             \"var_usage\": var_usage}, \"to_str\")\n    if value is None:\n        if hasattr(var.value, \"start\") and var_usage.info[\"convert_val\"]:\n            value = convert(var.value.start, var.value.end)\n        else:\n            if (isinstance(var.value, list)\n                    or var.value.__class__.__name__ == \"VariableValue\"):\n                value = \"\".join(var.value)\n            else:\n                value = var.value\n    return f\"{dec_prefix} {name}={value}\".strip()\n\n\ndef var_struct(var_usage, var, **kwargs):\n    var_upper, call_path = var.get_upper(), str(var_usage.call_path)\n    if var_upper and var_upper.is_struct:\n        return \"static class \" + call_path\n    return \"class \" + call_path\n\n\ndef var_usage_parser(var_usage, **kwargs):\n    var = var_usage.obj\n    usage_type = var_usage.usage_type\n    if usage_type == \"get\":\n        return var_get(var_usage, var, **kwargs)\n    elif usage_type == \"set\":\n        return var_set(var_usage, var, **kwargs)\n    elif usage_type == \"struct\":\n        return var_struct(var_usage, var, **kwargs)\n    raise NotImplementedError(\"Unknown Case\")\n\n\ndef to_str(var_stmt, **kwargs):\n    return \";\".join([var_usage_parser(var_usage, **kwargs)\n                     for var_usage in var_stmt.var_usages])\n\n\ndef var_set_match(var_stmt):\n    rng = range(var_stmt.start, var_stmt.end)\n    trigger = rng[0]\n    params = {\"var_stmt\": var_stmt}\n    for var_usage in var_stmt.var_usages:\n        var = var_usage.var\n        call_path = var_usage.call_path\n        if len(call_path) > 1:\n            upper = call_path[-2]\n            if upper.is_struct:\n                static_reset = len(var.linked_objs) != 1\n                instance_reset = False\n                struct_attr = next(iter(upper.attrs[var.abs_name].linked_objs))\n                for instance in upper.instances:\n                    if instance.attrs[var.abs_name] is not struct_attr:\n                        instance_reset = True\n                        break\n                if static_reset and instance_reset:\n                    rng = (rng, list(rng) +\n                           list(range(struct_attr.start, struct_attr.end)))\n                    params[\"attr\"] = struct_attr\n    return trigger, rng, params\n\n\ndef match(words, index, **kwargs):\n    var_stmt = words[index].tags[\"var_stmt\"]\n\n    if var_stmt.usage_type == \"set\":\n        return var_set_match(var_stmt)\n    return (var_stmt.start, range(var_stmt.start, var_stmt.end),\n            {\"var_stmt\": var_stmt})\n",
    "priority": 1
  },
  "-/to/Coll-Bridge/python/Coll-Bridge/reserved/word_map": {
    "tag": {
      "const": [
        {
          "conversion": "\"\\1\"",
          "matcher": "'(.*)'$"
        },
        "\\1"
      ]
    },
    "text": {
      ";": ";",
      "False": "false",
      "None": "null",
      "True": "true",
      "and": "&&",
      "break": "break",
      "or": "||",
      "pass": "",
      "raise": "throw"
    },
    "type": {
      "blk_end": "}",
      "blk_start": "{",
      "int": [
        {
          "conversion": "0\\1",
          "matcher": "0o(\\\\d)"
        },
        "\\1"
      ],
      "stmt_term": ";"
    }
  },
  "valid_paths": [
    "/to/Coll-Bridge/python/Coll-Bridge/operator_overloads/Coll-Bridge/String/in",
    "/to/Coll-Bridge/python/Coll-Bridge/lib_convs/bool",
    "/from/Coll-Bridge/types/ArrayList<String>",
    "/to/Coll-Bridge/python/Coll-Bridge/lib_convs/list",
    "/from/Coll-Bridge/types/void",
    "/from/Coll-Bridge/types/int[]",
    "/to/Coll-Bridge/python/Coll-Bridge/reserved/word_map",
    "/to/Coll-Bridge/python/Coll-Bridge/lib_convs/Coll-Bridge/re/Coll-Bridge/Match/span",
    "/from/Coll-Bridge/types/Matcher",
    "/to/Coll-Bridge/python/Coll-Bridge/lib_convs/Coll-Bridge/os/path",
    "/to/Coll-Bridge/python/Coll-Bridge/misc/operator",
    "/to/Coll-Bridge/python/Coll-Bridge/lib_convs/Coll-Bridge/str/format",
    "/to/Coll-Bridge/python/Coll-Bridge/operator_overloads/Coll-Bridge/Map-Entry<String,String>/[ ]",
    "/to/Coll-Bridge/python/Coll-Bridge/reserved/func_convert",
    "/to/Coll-Bridge/python/Coll-Bridge/lib_convs/Coll-Bridge/str/lstrip",
    "/to/Coll-Bridge/python/Coll-Bridge/operator_overloads/Coll-Bridge/String/[ ]",
    "/from/Coll-Bridge/types/Integer[]",
    "/to/Coll-Bridge/python/Coll-Bridge/operator_overloads/Coll-Bridge/Map-Entry<String,Map<String,String>>/[ ]",
    "/to/Coll-Bridge/python/Coll-Bridge/reserved/main_stmts",
    "/to/Coll-Bridge/python/Coll-Bridge/operator_overloads/Coll-Bridge/String/==",
    "/to/Coll-Bridge/python/Coll-Bridge/lib_convs/str",
    "/from/Coll-Bridge/types/double",
    "/to/Coll-Bridge/python/Coll-Bridge/lib_convs/range",
    "/to/Coll-Bridge/python/Coll-Bridge/misc/while",
    "/from/Coll-Bridge/types/ArrayList<Integer[]>",
    "/to/Coll-Bridge/python/Coll-Bridge/lib_convs/max",
    "/to/Coll-Bridge/python/Coll-Bridge/lib_convs/Coll-Bridge/os/Coll-Bridge/path/split",
    "/from/Coll-Bridge/types/boolean",
    "/to/Coll-Bridge/python/Coll-Bridge/obj_mod/str_format",
    "/to/Coll-Bridge/python/Coll-Bridge/operator_overloads/Coll-Bridge/->Map<String,Map<String,String>>/in",
    "/to/Coll-Bridge/python/Coll-Bridge/reserved/import_lib",
    "/to/Coll-Bridge/python/Coll-Bridge/lib_convs/Coll-Bridge/re/Pattern",
    "/to/Coll-Bridge/python/Coll-Bridge/misc/return",
    "/from/Coll-Bridge/types/null",
    "/from/Coll-Bridge/types/String[]",
    "/from/Coll-Bridge/types/re.Pattern",
    "/from/Coll-Bridge/types/ArrayList<Integer>",
    "/to/Coll-Bridge/python/Coll-Bridge/reserved/add_nglot_funcs",
    "/to/Coll-Bridge/python/Coll-Bridge/operator_overloads/Coll-Bridge/int/in",
    "/to/Coll-Bridge/python/Coll-Bridge/lib_convs/Coll-Bridge/str/rsplit",
    "/to/Coll-Bridge/python/Coll-Bridge/misc/for",
    "/to/Coll-Bridge/python/Coll-Bridge/lib_convs/Coll-Bridge/os/Coll-Bridge/path/isfile",
    "/to/Coll-Bridge/python/Coll-Bridge/lib_convs/Coll-Bridge/dict/items",
    "/from/get_type",
    "/from/Coll-Bridge/types/Map.Entry<String,Map<String,String>>",
    "/to/Coll-Bridge/python/Coll-Bridge/reserved/var_convert",
    "/to/Coll-Bridge/python/Coll-Bridge/lib_convs/os",
    "/to/Coll-Bridge/python/Coll-Bridge/lib_convs/Coll-Bridge/str/split",
    "/from/Coll-Bridge/types/Map<String,Map<String,String>>",
    "/to/Coll-Bridge/python/Coll-Bridge/lib_convs/Coll-Bridge/str/lower",
    "/from/Coll-Bridge/types/char",
    "/to/Coll-Bridge/python/Coll-Bridge/lib_convs/int",
    "/to/Coll-Bridge/python/Coll-Bridge/operator_overloads/Coll-Bridge/String/%",
    "/to/Coll-Bridge/python/Coll-Bridge/reserved/get_coll_type",
    "/to/Coll-Bridge/python/Coll-Bridge/obj_mod/global_objs",
    "/to/Coll-Bridge/python/Coll-Bridge/operator_overloads/Coll-Bridge/ArrayList<Integer[]>/[ ]",
    "/from/Coll-Bridge/types/int",
    "/to/Coll-Bridge/python/Coll-Bridge/lib_convs/Coll-Bridge/re/search",
    "/to/Coll-Bridge/python/Coll-Bridge/operator_overloads/Coll-Bridge/char/*",
    "/to/Coll-Bridge/python/Coll-Bridge/lib_convs/Coll-Bridge/list/extend",
    "/from/Coll-Bridge/types/Map.Entry<String,String>",
    "/to/Coll-Bridge/python/Coll-Bridge/lib_convs/Coll-Bridge/os/Coll-Bridge/path/splitext",
    "/from/Coll-Bridge/types/Map<String,String>",
    "/from/Coll-Bridge/types/double[]",
    "/to/Coll-Bridge/python/Coll-Bridge/reserved/boilerplate",
    "/from/Coll-Bridge/types/String",
    "/to/Coll-Bridge/python/Coll-Bridge/lib_convs/Coll-Bridge/str/find",
    "/to/Coll-Bridge/python/Coll-Bridge/obj_mod/ret_check",
    "/to/Coll-Bridge/python/Coll-Bridge/obj_mod/this_prefix_cls",
    "/to/Coll-Bridge/python/Coll-Bridge/operator_overloads/Coll-Bridge/String/*",
    "/to/Coll-Bridge/python/Coll-Bridge/lib_convs/Coll-Bridge/list/append",
    "/from/Coll-Bridge/types/int[][]",
    "/from/Coll-Bridge/types/Integer",
    "/to/Coll-Bridge/python/Coll-Bridge/lib_convs/Coll-Bridge/re/compile",
    "/to/Coll-Bridge/python/Coll-Bridge/lib_convs/len",
    "/to/Coll-Bridge/python/Coll-Bridge/lib_convs/print",
    "/to/Coll-Bridge/python/Coll-Bridge/operator_overloads/Coll-Bridge/->Map<String,String>/in",
    "/from/Coll-Bridge/types/Pattern",
    "/to/Coll-Bridge/python/Coll-Bridge/obj_mod/static_attr_extend",
    "/to/Coll-Bridge/python/Coll-Bridge/lib_convs/min",
    "/to/Coll-Bridge/python/Coll-Bridge/lib_convs/Coll-Bridge/str/strip",
    "/to/Coll-Bridge/python/Coll-Bridge/func_call/new_const",
    "/to/Coll-Bridge/python/Coll-Bridge/misc/if",
    "/to/Coll-Bridge/python/Coll-Bridge/reserved/check_attrs",
    "/to/Coll-Bridge/python/Coll-Bridge/operator_overloads/Coll-Bridge/Map<String,String>/[ ]",
    "/to/Coll-Bridge/python/Coll-Bridge/lib_convs/pow",
    "/to/Coll-Bridge/python/Coll-Bridge/operator_overloads/Coll-Bridge/ArrayList<Integer>/[ ]",
    "/to/Coll-Bridge/python/Coll-Bridge/misc/symbols",
    "/to/Coll-Bridge/python/Coll-Bridge/lib_convs/re",
    "/from/Coll-Bridge/types/re-Match",
    "/to/Coll-Bridge/python/Coll-Bridge/lib_convs/Coll-Bridge/str/rstrip",
    "/to/Coll-Bridge/python/Coll-Bridge/lib_convs/not",
    "/to/Coll-Bridge/python/Coll-Bridge/keyword_triggers/not",
    "/from/Coll-Bridge/types/List<Integer>",
    "/from/Coll-Bridge/types/List<Double>",
    "/from/Coll-Bridge/types/List<String>",
    "/to/Coll-Bridge/python/Coll-Bridge/operator_overloads/Coll-Bridge/char/==",
    "/to/Coll-Bridge/python/Coll-Bridge/eq_types/str",
    "/to/Coll-Bridge/python/Coll-Bridge/eq_types/float",
    "/to/Coll-Bridge/python/Coll-Bridge/eq_types/None",
    "/to/Coll-Bridge/python/Coll-Bridge/eq_types/int",
    "/to/Coll-Bridge/python/Coll-Bridge/eq_types/bool",
    "/to/Coll-Bridge/python/Coll-Bridge/eq_types/io-TextIOWrapper",
    "/to/Coll-Bridge/python/Coll-Bridge/eq_types/-Any-",
    "/to/Coll-Bridge/python/Coll-Bridge/eq_types/list",
    "/to/Coll-Bridge/python/Coll-Bridge/eq_types/range",
    "/to/Coll-Bridge/python/Coll-Bridge/eq_types/dict_items",
    "/from/Coll-Bridge/types/Map-Entry<String,Map<String,String>>",
    "/from/Coll-Bridge/types/Map-Entry<String,String>",
    "/to/Coll-Bridge/python/Coll-Bridge/eq_types/dict",
    "/to/Coll-Bridge/python/Coll-Bridge/eq_types/tuple",
    "/to/Coll-Bridge/python/Coll-Bridge/eq_types/re-Pattern",
    "/to/Coll-Bridge/python/Coll-Bridge/eq_types/re-Match",
    "/from/Coll-Bridge/types/Object[]",
    "/to/Coll-Bridge/python/Coll-Bridge/operator_overloads/Coll-Bridge/String/!=",
    "/to/Coll-Bridge/python/Coll-Bridge/operator_overloads/Coll-Bridge/ArrayList<String>/+",
    "/to/Coll-Bridge/python/Coll-Bridge/operator_overloads/Coll-Bridge/Object[]/+"
  ]
}